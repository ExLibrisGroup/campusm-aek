if(!window.CampusM) {
  window.CampusM = {};
}

var CampusM = window.CampusM;

var localForage = require("localforage");
var blobUtil = require("blob-util");

var blobToDataURI = function(blob) {
  return blobUtil.blobToBase64String(blob).then((b64)=>{
    return `data:${blob.type};base64,${b64}`;
  });
};

var canCache = function(xhr) {
  var cacheControl = xhr.getResponseHeader("cache-control");
  if(!cacheControl) { return false; }

  var tests = [
    /no-cache/i,
    /no-store/i,
    /max-age= *0\b/i,
    /s-maxage= *0\b/i
  ];

  for(var test of tests) {
    if(cacheControl.match(test)) {
      return false;
    }
  }

  return true;
};

class AssetStore {

  constructor(storeKey) {
    this.storeKey = storeKey;
    this.store = localForage.createInstance({name:storeKey});
    this.imagePromises = {};
    this.fetching = {};
  }

  fetchAsset(url) {
    var promise = this.fetching[url] || new Promise((resolve)=>{
      this.store.getItem(url)
      .then((code)=>{
        if(code) {
          // console.log("code found in storage - returning code");
          resolve({code});
        }
        else {
          // console.log("code not found in storage - requesting code");

          // We'll download the code with AJAX.
          var request = new XMLHttpRequest();

          request.open('GET', url, true);
          // request.responseType = 'blob';

          // When the AJAX state changes, save the code locally.
          request.addEventListener('readystatechange', ()=> {
            if (request.readyState === 4) { // readyState DONE
              if(request.status === 200 && request.responseText) {
                if(canCache(request)) {
                  this.store.setItem(url,request.responseText);
                }
                code = request.responseText;
                resolve({code});
              }
              else {
                // console.log("Failed to retrieve data for " + url,request);
                resolve({err:Error("Could not retrieve data"),url});
              }
            }

          });

          request.send();
        }
      });
    });

    this.fetching[url] = promise;

    return promise;
  }

  fetchAssets(urls) {
    if(!urls) {
      urls = [];
    }
    if(!Array.isArray(urls)) {
      urls = [urls];
    }
    // console.log("urls",urls);
    return Promise.all(urls.map((url)=>{
      return this.fetchAsset(url);
    }));
  }

  loadJS(urls) {
    return this.fetchAssets(urls)
    .then((fetchResults)=>{
      // console.log("fetchResults",fetchResults);
      var promise = Promise.resolve();
      fetchResults.forEach((result)=>{
        promise = promise.then(this.executeJS(result));
      });
      return promise;
    });
  }

  executeJS(obj) {
    return new Promise((resolve)=>{
      if(obj.code) {
        (new Function(obj.code))();
        resolve();
      }
      else {
        if(CampusM.loadJS) {
          console.warn(`AssetStore: unable to fetch "${obj.url}" with XMLHttpRequest - should load but won't be able to add asset store which may prevent offline support`); //eslint-disable-line no-console
          CampusM.loadJS(obj.url,resolve);
        }
        else {
          console.warn(`AssetStore: unable to fetch "${obj.url}"`); //eslint-disable-line no-console
        }
      }
    });
  }

  loadCSS(urls) {
    return this.fetchAssets(urls)
    .then((fetchResults)=>{
      var promise = Promise.resolve();
      fetchResults.forEach((result)=>{
        promise = promise.then(this.applyCSS(result));
      });
      return promise;
    });
  }

  applyCSS(obj) {
    return new Promise((resolve)=>{
      if(obj.code) {

        var style = document.createElement('style');

        // Needed to enable `style.styleSheet` in IE
        style.setAttribute('type', 'text/css');

        if (style.styleSheet) {
          // We should append style element to DOM before assign css text to
          // workaround IE bugs with `@import` and `@font-face`.
          // https://github.com/andrewwakeling/ie-css-bugs
          document.head.appendChild(style);

          style.styleSheet.cssText = obj.code; // IE method
        } else {
          style.appendChild(document.createTextNode(obj.code)); // others
          document.head.appendChild(style);
        }
        resolve();
      }
      else {
        if(CampusM.loadCSS) {
          console.warn(`AssetStore: unable to fetch "${obj.url}" with XMLHttpRequest - should load but won't be able to add asset store which may prevent offline support`); //eslint-disable-line no-console
          CampusM.loadCSS(obj.url,resolve);
        }
        else {
          console.warn(`AssetStore: unable to fetch "${obj.url}"`); //eslint-disable-line no-console
        }
      }
    });
  }

  getImgSrc(url) {

    if (url.match(/^data\:/i)) {
      return Promise.resolve(url);
    }

    var promise = this.imagePromises[url] || new Promise((resolve,reject)=>{

      this.store.getItem(url)
      .then((blob)=>{
        if(blob) {
          // console.log("blob found in storage - returning dataURI");
          resolve(blobToDataURI(blob));
        }
        else {
          // console.log("blob not found in storage - requesting image");

          // We'll download the image with AJAX.
          var request = new XMLHttpRequest();

          // Let's get the first user's photo.
          request.open('GET', url, true);
          request.responseType = 'blob';

          // When the AJAX state changes, save the photo locally.
          request.addEventListener('readystatechange', ()=> {
            if (request.readyState === 4) { // readyState DONE
              if(request.status === 200) {
                if(canCache(request)) {
                  this.store.setItem(url, request.response);
                }
                resolve(blobToDataURI(request.response));
              }
              else {
                // console.log("Failed to retrieve data for " + url,request);
                reject(Error("Could not retrieve data"));
              }
            }

          });

          request.send();
        }
      });
    });

    this.imagePromises[url] = promise;

    return promise;
  }

}

var assetStore = new AssetStore("CampusM_AssetStore");

assetStore.AssetStore = AssetStore;

if(module) {
  module.exports = assetStore;
}


window.CampusM.assetStore = assetStore;

module.exports = assetStore;
