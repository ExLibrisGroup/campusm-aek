_ = require("lodash")
repl = require("repl")
stream = require("stream")
spawnargs = require("spawn-args")
inquirer = require("inquirer")
Promise = require("rsvp").Promise

utils = require("./utils")

prompt = utils.prompt

chalk = require("chalk")

path = require("path")
fs = require("fs")


inquirerOptionsTransform = (opts,data={})->
  
  # type: (String) Type of the prompt. Defaults: input - Possible values: input, confirm, list, rawlist
  # name: (String) The name to use when storing the answer in the anwers hash.
  # message: (String|Function) The question to print. If defined as a function, the first parameter will be the current inquirer session answers.
  # default: (String|Number|Array|Function) Default value(s) to use if nothing is entered, or a function that returns the default value(s). If defined as a function, the first parameter will be the current inquirer session answers.
  # choices: (Array|Function) Choices array or a function returning a choices array. If defined as a function, the first parameter will be the current inquirer session answers.
  # Array values can be simple strings, or objects containing a name (to display) and a value properties (to save in the answers hash). Values can also be a Separator.
  # validate: (Function) Receive the user input and should return true if the value is valid, and an error message (String) otherwise. If false is returned, a default error message is provided.
  # filter: (Function) Receive the user input and return the filtered value to be used inside the program. The value returned will be added to the Answers hash.
  # when: (Function) Receive the current user answers hash and should return true or false depending on whether or not this question should be asked.

  

  opts = _.clone(opts)

  promise = Promise.resolve(opts)

  if opts.beforeInquiry
    promise = opts.beforeInquiry(opts,data)
    

  return promise.then (opts)->
  
    opts.type = opts.inputType || (opts.flag && "confirm") || opts.choices && (opts.list && "checkbox" || "list") || opts.list && "rawlist" || "input"
    
    delete opts.transform
    delete opts.filter

    if !opts.message
      if opts.help && _.isFunction(opts.help)
        opts.message = ()->
          helpPromise = utils.runPromise(opts.help)
          done = this.async()
          helpPromise.then(done)
      else
        opts.message = opts.help || "Please enter value for #{opts.name}"

    for opt in ["message","default","choices"]
      do(opt)->
        if _.isFunction(opts[opt])
          orig = opts[opt]
          opts[opt] = ()->
            val = orig.call(this,data)

    return opts

  

nomnomOptionsTransform = (opts,data={})->

  # abbr
  # flag
  # metavar
  # help
  # default
  # type
  # callback
  # position
  # list
  # required
  # choices - needs transforming to string array
  # hidden

  promise = Promise.resolve()
  opts = _.clone(opts)

  delete opts.transform
  delete opts.choices

  if opts.required && opts.promptIfMissing
    delete opts.required

  if opts.promptIfMissing
    delete opts.default

  for opt in ["help","default"]
    do(opt)->
      if _.isFunction(opts[opt])
        promise = promise.then(()->utils.runPromise(opts[opt],data[opt])).then (val)->
          opts[opt] = val
          return opts

  promise.then ()->
    if opts.required
      opts.help = opts.help && (opts.help + " ") || ""
      opts.help = chalk.grey(opts.help) + chalk.yellow("(required)")


  # promise = promise.then ()->
  #   opts.choices = opts.choices?.reduce (prev,curr)->
  #     val = _.isString(curr) || curr.value
  #     if val?
  #       prev.push(curr)
  #     return prev
  #   ,[]



  return promise.then ()->
    return opts
  


class OblongCli

  constructor:(commands,@options={})->
    @log = @options.log
    
    helpCommand = 
      name:"help"
      help:"get help/usage for command"
      options:[
        name:"helpCommand"
        message:"Choose a command you want help with"
        choices:commands.filter((command)->!command.nolist).map (command)->
          command.name
        position:1
      ]
      callback:(opts)=>
        command = opts.helpCommand || ""
        helpCli = new OblongCli(commands,@options)
        helpCli.ready.then ()->
          helpCli.parse "#{command} --help"

    @commands = [helpCommand].concat(commands)

    @nomnom = require("nomnom")()

    @ready = Promise.resolve()

    
    if @options.scriptName
      @nomnom.script(@options.scriptName)


    for command in @commands
      do(command)=>
        if command.type=="session"
          command.callback = @startSession
        com = @nomnom.command(command.name)
        if command.options
          for opt in command.options
            do(opt)=>
              if opt.required and !opt.validate
                opt.validate = (val)=>
                  if _.isArray(val) && val.length==0
                    return "Please select at least one option"
                  return !!val || "This is not optional, please enter a value"
              @ready = @ready.then(()->nomnomOptionsTransform(opt,{})).then (opt)->
                com.option(opt.name,opt)
        for prop in ["help","usage"]
          if command[prop]
            com[prop] = command[prop]

        com.callback (values)=>
          @processCommand(command,values).catch().then(@finish)

    @nomnom.nocommand().options("version":{flag:true}).callback (opts)=>
      if opts.version
        console.log JSON.parse(fs.readFileSync(path.resolve(__dirname,"../../package.json"))).version
      else
        @session=true
        question = 
          name:"command"
          message:"Please choose a command to execute"
          type:"list"
          choices:@commands.reduce (choices,command)->
            unless command.nolist
              choices.push
                name:chalk.bold(command.name) + (command.help && chalk.grey.italic(" - "+command.help) || "")
                value:command.name
            return choices
          ,[]
        
        inquirer.prompt [question],(answers)=>
          @processCommand(answers.command,{})

    @nomnom.printer (str,code)=>
      if !@session
        console.log(str)
        process.exit(code || 0)
      @finish()

  finish:()=>
    # @log.info "FINISH"
    if @session
      @commandPrompt()
    # else
    #   process.exit(0)

  startSession:()=>
    @session = true
    @commandPrompt()

  commandPrompt:()->
    prompt @options.sessionPrompt,(cmd)=>
      @parse(cmd)


  processCommand:(command,values={},checked=[])->

    if _.isString(command)
      command = _.findWhere(@commands,name:command)

    promise = Promise.resolve()

    if command

      #prompt for any required values

      # validate values
      for opt in (command.options ? [])
        do(opt)=>

          value = values[opt.name]

          if !opt.noPrompt && (@session || (!value && opt.promptIfMissing)) && opt.name not in checked
            promise = promise.then ()->
              inquirerOptionsTransform(opt,values).then (opt)=>
                if opt.value?
                  value = values[opt.name] = opt.value
                  return true
                new Promise (resolve,reject)->
                  inquirer.prompt [opt],(answers)=>
                    value = values[opt.name] = answers[opt.name]
                    checked = checked.concat [opt.name]
                    resolve()

          else if !@session && opt.default && !value?
            usedDefault = true
            promise = promise.then(()->utils.runPromise(opt.default,values)).then (def)=>
              value = values[opt.name] = def

          promise = promise.then ()=>
            promise = Promise.resolve()
            # if opt.required && !value
            #   promise = promise.then ()->
            #     err = new Error("A value for '#{opt.name}' is required")
            #     err.name = "ValidationError"
            #     err.command = command
            #     err.option = opt
            #     err.input = value
            #     throw err

            if opt.choices && value && value != opt.default
              promise = promise.then(()->utils.runPromise(opt.choices,values)).then (choices)=>
                if choices
                  choices = choices.map (choice)-> _.isObject(choice) && choice.values || choice
                  list = _.isArray(value) && value || [value]
                  unless opt.choiceIsOpen
                    for val in list
                      if val not in choices
                        err = new Error("Value of '#{opt.name}' should be one of :\n "+chalk.green("-")+" '"+choices.join("'\n "+chalk.green('-')+" '")+"'")
                        err.name = "ValidationError"
                        err.command = command
                        err.option = opt
                        err.input = value
                        throw err

            if opt.validate
              promise = promise.then(()->utils.runPromise(opt.validate,value,values)).then (valid)=>
                if !valid
                  err = new Error("#{opt.name} is not valid")
                  err.name = "ValidationError"
                  err.command = command
                  err.option = opt
                  err.input = value
                  throw err

            if opt.transform and !usedDefault
              promise = promise.then(()->utils.runPromise(opt.transform,value,values)).then (result)->
                values[opt.name] = result

            return promise


      promise = promise.then ()=>
        if command.callback
          return Promise.resolve(command.callback(values))
        else
          @log.warn "The command '#{command.name}' has not yet been implemented" 
          return false

      promise.catch (e)=>
        if @session && e.name=="ValidationError"
          command = e.command
          option = e.option
          inquirerOptionsTransform(option,values).then (opt)=>
            inquirer.prompt [opt],(answers)=>
              @processCommand(command,_.extend({},values,answers,checked))

        else
          @log.error chalk.grey(e.name)+": ",e.message
        
        throw(e)

      return promise  

    else
      return Promise.reject(Error("Command not found")) 
      


  parse:(options)->
    options = options && (_.isArray(options) || spawnargs(options))
    @nomnom.parse(options)


module.exports = OblongCli
