"use strict";

var utils = require("../utils");
var getSemanticSection = utils.getSemanticSection;
var removeSemanticSection = utils.removeSemanticSection;
var reRule = utils.reRule;
var thru = require("through2").obj;
var chalk = require("chalk");


// clean up semantic definitions
module.exports = function() {
  return thru(function(file,enc,cb) {
    var contents = file.contents.toString();
    
    console.log(chalk.magenta("cleanSemanticDefs:"),file.relative);

    // find color variations
    var colorSection = getSemanticSection(contents,"variations","colors");
    var colorSrc = colorSection;
    if(file.relative!=="form.less") { // form inverted colors section doesn't include colours!!
      colorSrc += getSemanticSection(contents,"variations","inverted colors");
      if(!colorSection) {colorSection = colorSrc; }
    }
    // find color rules in message types
    colorSrc += getSemanticSection(contents,"variations","types",null,"colors");
    if(!colorSection) {colorSection = colorSrc; }

    // find colors in grid
    colorSrc += getSemanticSection(contents,"variations","colored");
    if(!colorSection) {colorSection = colorSrc; }
    
    var newColorSrc = "";

    // find purple rules
    var purpleRules = colorSrc.match(reRule("\\.purple")) || [];
    purpleRules.forEach(function(rule) {
      newColorSrc += rule+"\n";
    });
    
    if(newColorSrc) {
      newColorSrc = ".ombTheme {\n"+newColorSrc+"}";
      // console.log(chalk.blue("colorSection"));
      // console.log(chalk.grey(newColorSrc));
    }

    contents = contents.replace(colorSection,newColorSrc);


    // some "inverted" sections also contain colours - we need to check the rules in theses individually
    
    var invertedSrc = getSemanticSection(contents,"variations","inverted");
    var invertedContent = invertedSrc;

    if(invertedContent) {

      // remove all colours instead of purple
      invertedContent = invertedContent.replace(reRule("\\.(black|blue|green|orange|pink|red|teal|yellow)"),"");

      // find all purple rules
      purpleRules = invertedContent.match(reRule("\\.purple"));
      if(purpleRules) {
        purpleRules.forEach(function(rule) {
          invertedContent = invertedContent.replace(rule,".ombTheme{\n"+rule+"}");
        });
      }
      
      contents = contents.replace(invertedSrc,invertedContent);
    }

    // remove colors from grid
    contents = removeSemanticSection(contents,"variations","colored");

    // remove colors from messages
    contents = removeSemanticSection(contents,"variations","types",null,"colors");

    // remove inverted colors
    if(file.relative!=="form.less") { // form inverted colors section doesn't include colours!!
      contents = removeSemanticSection(contents,"variations","inverted colors");
    }

    // remove primary section
    //contents = removeSemanticSection(contents,"variations","primary");

    // remove secondary section
    //contents = removeSemanticSection(contents,"variations","secondary");

    
    // remove wrapper and loadUIOverrides
    contents = contents.replace(".loadUIOverrides();","");

    //remove font loader
    contents = contents.replace(".loadFonts();","");


    // check for references to "yellow"
    if(contents.match(/yellow/gi)) {
      console.log(chalk.bgYellow.black(" WARN "),"contents still contain colour references");
    }

    // check for references to "primary"
    if(contents.match(/primary/gi)) {
      console.log(chalk.bgYellow.black(" WARN "),"contents still contain 'primary' references");
    }

    file.contents = new Buffer(contents);

    this.push(file);

    cb();

  });
};
