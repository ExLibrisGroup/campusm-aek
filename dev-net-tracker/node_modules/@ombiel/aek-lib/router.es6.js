var utils = require("./utils");
var _ = utils;
var pathtoRegexp = require('path-to-regexp');





/**
   * Initialize `Route` with the given HTTP `path`,
   * and an array of `callbacks` and `options`.
   *
   * Options:
   *
   *   - `sensitive`    enable case-sensitive routes
   *   - `strict`       enable strict matching for trailing slashes
   *
   * @param {String} path
   * @param {Object} options.
   * @api private
   */

function Route(path, options) {
  options = options || {};
  this.path = (path === '*') ? '(.*)' : path;
  this.method = 'GET';
  this.regexp = pathtoRegexp(this.path,
    this.keys = [],
    options.sensitive,
    options.strict);
}


/**
 * Return route middleware with
 * the given callback `fn()`.
 *
 * @param {Function} fn
 * @return {Function}
 * @api public
 */

Route.prototype.middleware = function(fn){
  var self = this;
  return function(ctx, next){
    if(self.match(ctx.path, ctx.params)) { return fn(ctx, next); }
    next();
  };
};

/**
 * Check if this route matches `path`, if so
 * populate `params`.
 *
 * @param {String} path
 * @param {Array} params
 * @return {Boolean}
 * @api private
 */

Route.prototype.match = function(path, params){
  var keys = this.keys,
      qsIndex = path.indexOf('?'),
      pathname = ~qsIndex
        ? path.slice(0, qsIndex)
        : path,
      m = this.regexp.exec(decodeURIComponent(pathname));

  if (!m) { return false; }

  for (var i = 1, len = m.length; i < len; ++i) {
    var key = keys[i - 1];

    var val = (typeof m[i] === 'string')
      ? decodeURIComponent(m[i])
      : m[i];

    if (key) {
      params[key.name] = undefined !== params[key.name]
        ? params[key.name]
        : val;
    } else {
      params.push(val);
    }
  }

  return true;
};




function Context(path) {

  var i = path.indexOf('?');

  this.canonicalPath = path;
  this.path = path;//.replace(base, '') || '/';

  this.title = document.title;
  // this.state = state || {};
  // this.state.path = path;
  this.querystring = ~i
    ? path.slice(i + 1)
    : '';
  this.pathname = ~i
    ? path.slice(0, i)
    : path;
  this.params = [];

  this.query = utils.parseQueryString(this.querystring);

  // fragment
  this.hash = '';
  if (!~this.path.indexOf('#')) { return; }
  var parts = this.path.split('#');
  this.path = parts[0];
  this.hash = parts[1] || '';
  this.querystring = this.querystring.split('#')[0];
}


Context.prototype.modifyQuery = function(newParams,replace) {
  var params = _.extend({},this.query,newParams);
  var queryString = _.param(params);
  if(queryString) { queryString = "?" + queryString; }
  this.router[replace === "back" && "backTo" || replace && "replace" || "goto"](this.pathname + queryString);
};

// /**
//  * Push state.
//  *
//  * @api private
//  */

// Context.prototype.pushState = function(){
//   history.pushState(this.state
//     , this.title
//     , hashbang && this.path !== '/'
//       ? '#!' + this.path
//       : this.canonicalPath);
// };

/**
 * Save the context state.
 *
 * @api public
 */

// Context.prototype.save = function(){
//   history.replaceState(this.state
//     , this.title
//     , hashbang && this.path !== '/'
//       ? '#!' + this.path
//       : this.canonicalPath);
// };






class Router {
  constructor(opts = {}) {
    this.opts = opts;
    this.history = [window.location.hash.substr(1) || "/"];
    this.historyState = {};
    this.currentHistoryIndex = 0;

    this.onClick = this.onClick.bind(this);

    if(opts.useHash == null) {
      opts.useHash = utils.isWeb();
    }

    if(opts.useHash) {
      this.useHash = true;
      this.onHashChange = this.onHashChange.bind(this);
    }

    if(this.useHash) {
      if(window.history.state && window.history.state.history) {
        this.history = window.history.state.history;
        if(window.history.state.historyState != null) {
          this.historyState = window.history.state.historyState;
        }
        if(window.history.state.currentHistoryIndex != null) {
          this.currentHistoryIndex = window.history.state.currentHistoryIndex;
        }
      }
      else {
        this.resetState();
      }
    }
    else {
      if(!opts.noPolyfill) {
        /*
        polyfill to use link elements in iOS
        Currently iOS native app intercepts hash changes and launches a new webview to load them into
        */

        document.addEventListener("click",this.onClick,false);
      }
    }

    this.callbacks = [];

  }

  onClick(e) {

    var target = e.target;
    var a;
    while(!a && target) {
      if(target.tagName && target.tagName.toLowerCase() === "a") {
        a = target;
      }
      target = target.parentElement;
    }
    if(a) {
      var href = a.getAttribute("href");
      if(href.indexOf("#/") === 0) {
        this.goto(href);
        e.preventDefault();
      }
    }
  }

  addRoute(path,cb) {
    var route = new Route(path);
    let callback = route.middleware(cb);
    this.callbacks.push(callback);
    return callback;
  }

  removeRoute(cb) {
    this.callbacks = _.without(this.callbacks,cb);
  }

  start(opts = {}) {

    if(this._started) {
      return;
    }
    this._started = true;

    utils.extend(this.opts,opts);
    if(this._running) { return; }
    this._running = true;

    var startPath = location.hash.substr(1);
    if(this.useHash) {
      window.addEventListener('hashchange', this.onHashChange, false);
    }

    if(!startPath) {
      startPath = "/";
    }

    var router = this;
    window.goBack = function() {
      return router.goBack();
    };

    this.show(startPath);

  }

  getHistoryState(index) {
    return this.historyState[index] || {};
  }

  setHistoryState(index,state) {
    this.historyState[index] = state;
  }

  updateHistoryState(index,state) {
    this.setHistoryState(index,utils.extend({},this.getHistoryState(index),state));
  }

  show(path,direction = "forward") {
    path = this.cleanPath(path);
    var ctx = this.currentCtx = this.currentContext = Router.currentContext = new Context(path);
    ctx.router = this;
    ctx.transitionDirection = direction;
    ctx.historyIndex = this.currentHistoryIndex;
    ctx.getHistoryState = this.getHistoryState.bind(this,this.currentHistoryIndex);
    ctx.setHistoryState = this.setHistoryState.bind(this,this.currentHistoryIndex);
    ctx.updateHistoryState = this.updateHistoryState.bind(this,this.currentHistoryIndex);
    this.dispatch(ctx);

    // var currentHistoryIndex = this.currentHistoryIndex;
    // this.history.forEach(function(path,i) {
    //   // console.log(i,path,(i==currentHistoryIndex && "CURRENT" || ""))
    // });

    return ctx;
  }

  dispatch(ctx) {
    var i = 0;
    var router = this;
    function next() {
      var fn = router.callbacks[i++];
      if (!fn) {
        return router.unhandled(ctx);
      }
      fn(ctx, next);
    }

    next();
  }

  cleanPath(path) {
    if(path === "*") {
      return "*";
    }
    path = path.replace("#","");
    if(path.indexOf("/") !== 0) {
      path = "/" + path;
    }
    return path;
  }

  getCurrentPath() {
    return this.history[this.currentHistoryIndex];
  }

  replace(path) {
    path = this.cleanPath(path);
    if(path === this.getCurrentPath()) {
      return;
    }
    this.history = this.history
      .slice(0,this.currentHistoryIndex)
      .concat([path])
      .concat(this.history.slice(this.currentHistoryIndex + 1));

    // remove historyState
    this.setHistoryState(this.currentHistoryIndex,{});

    if(this.useHash) {
      this._silentHashChange = true;
      location.replace("#" + path);
    }
    this.show(path);
  }

  goto(path) {
    path = this.cleanPath(path);
    if(path === this.getCurrentPath()) {
      return;
    }
    // console.log("GOTO",path)

    // clear historyState in front
    utils.each(this.historyState,function(state,index) {
      if(index > this.currentHistoryIndex) {
        this.setHistoryState(index,{});
      }
    }.bind(this));

    this.currentHistoryIndex++;
    this.history = this.history.slice(0,this.currentHistoryIndex).concat([path]);
    this.show(path);
    this.updateHash(path);
  }

  backTo(path,useHash = true) {
    path = this.cleanPath(path);
    if(path === this.getCurrentPath()) {
      return;
    }
    var historyIndex = this.history.indexOf(path);
    if(historyIndex > -1) {
      this.goBack(this.currentHistoryIndex - historyIndex,useHash);
    }
    else {
      this.goto(path);
    }
  }

  goBack(steps = 1,useHash = true) {
    if(this.useHash && useHash) {
      window.history.go(-steps);
    }
    else {
      this.currentHistoryIndex -= steps;
      var returnVal = true;
      if(this.currentHistoryIndex < 0) {
        this.currentHistoryIndex = 0;
        returnVal = false;
      }
      var path = this.history[this.currentHistoryIndex];
      this.updateHash(path);
      this.show(path,"back");

      return returnVal;
    }
  }

  unhandled() { // has ctx argument

  }

  updateHash(path) {
    path = this.cleanPath(path);
    if(this.useHash && path !== location.hash.substr(1)) {
      this._silentHashChange = true;
      if(path === "/") {
        if(window.location.hash) {
          window.location.hash = "";
        }
      }
      else {
        window.location.hash = path;
      }
    }
  }

  onHashChange() {
    if(!this._silentHashChange) {

      var path = location.hash.substr(1);
      path = this.cleanPath(path);
      var historyIndex = this.history.indexOf(path);
      var historyState = this.useHash && window.history.state;

      if(historyState) {
        if(history.state.currentHistoryIndex != null) {
          historyIndex = history.state.currentHistoryIndex;
        }
      }

      if(historyIndex > -1 && historyIndex < this.currentHistoryIndex && historyState) {
        this.goBack(this.currentHistoryIndex - historyIndex,false);
      }
      else {
        this.goto(path);
      }
    }
    this._silentHashChange = false;

    this.resetState();
  }

  resetState() {
    if(window.history.replaceState) {
      window.history.replaceState({currentHistoryIndex:this.currentHistoryIndex,history:this.history,historyState:this.historyState},"");
    }
  }

  stop() {
    document.removeEventListener('click',this.onClick,false);
    if(!this._running) { return; }
    this._running = false;
    window.removeEventListener('hashchange', this.onHashChange, false);
  }
}

Router.Route = Route;
Router.Router = Router;

module.exports = Router;
