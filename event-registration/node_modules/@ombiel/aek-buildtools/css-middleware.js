var fs = require("fs");
var chokidar = require("chokidar");
var glob = require("glob");
var path = require("path");
var Promise = require("rsvp").Promise;
var log = require("@ombiel/aek-log");
var _ = require("lodash");
var less = require("less");
var stylus = require("stylus");
var notifier = require("./lib/notifier");
var LessPluginAutoPrefix = require('less-plugin-autoprefix');
var mkdirp = require('mkdirp');

var pkg = require("@ombiel/aek-fstore")("./package.json");

var options = {
  autoprefixer:require("./lib/conf/autoprefixer")
};
var transpilePromise;
var transpile;
var chalk = require("chalk");

var sourceMapRootpath = "aek:///" + pkg.get("name") + "/src/css/";

var lessDefaults = {
  dev:{
    sourceMap:{
      sourceMapFileInline:true,
      sourceMapRootpath:sourceMapRootpath
    }
  },
  prod:{
    compress:true
  }
};

var stylusDefaults = {
  dev:{
    sourcemap:{
      comment:false,
      inline:true,
      sourceRoot:sourceMapRootpath
    }
  },
  prod:{
    compress:true
  }
};

function transpileLess(filePath,devMode,opts) {

  var conf = _.merge({},lessDefaults,options);
  _.merge(conf,(devMode ? conf.dev : conf.prod));
  _.merge(conf,conf.less,opts);

  if(!conf.filename) {
    conf.filename = filePath;
    if(conf.sourceMap) {
      conf.sourceMap.sourceMapBasepath = path.dirname(filePath);
    }
  }

  var autoprefixPlugin = new LessPluginAutoPrefix(conf.autoprefixer);

  if(!conf.plugins) {
    conf.plugins = [];
  }

  conf.plugins.push(autoprefixPlugin);

  return new Promise(function(resolve) {
    fs.readFile(filePath,function(err,content) {
      if(err) { resolve(err); }
      else {
        less.render(content.toString(),conf).then(function(output) {

          resolve(output.css);

        },function(lessErr) {

          var errorPosition = lessErr.filename + " " + lessErr.line + ":" + lessErr.column;

          notifier.notify({title:"Less Transpile Error",sound:"Basso",message:errorPosition + " \n" + lessErr.message});
          log.error("Less transpile error");
          log.error(errorPosition);
          log.error(lessErr.message);
          resolve(lessErr);
        });
      }
    });
  });
}

function transpileStylus(filePath,devMode,opts) {

  var conf = _.merge({},stylusDefaults,options);
  _.merge(conf,(devMode ? conf.dev : conf.prod));
  _.merge(conf,conf.stylus,opts);

  if(!conf.filename) {
    conf.filename = filePath;
    if(conf.sourcemap) {
      conf.sourcemap.basePath = path.dirname(filePath);
    }
  }

  return new Promise(function(resolve) {
    fs.readFile(filePath,function(err,content) {
      if(err) { resolve(err); }
      else {
        var compiler = stylus(content.toString(),conf);

        if(conf.define) {
          _.each(conf.define,function(value,key) {
            compiler = compiler.define(key,value);
          });
        }
        compiler.use(require("autoprefixer-stylus")(conf.autoprefixer));
        compiler.render(function(stylusErr,output) {

          if(stylusErr) {

            notifier.notify({title:"Stylus Transpile Error",sound:"Basso",message:stylusErr.message});
            log.error("Stylus transpile error");
            log.error(stylusErr.message);
            resolve(stylusErr);
          }
          else {
            resolve(output);
          }

        });
      }
    });
  });
}

var watch = _.once(function() {
  log.info("Watching css...");
  chokidar.watch(path.resolve(options.srcBase),{ignoreInitial:true}).on("all",_.debounce(function() {
    transpile(true);
  },100));
});

transpile = function(devMode,opts) {

  log.info("Transpiling css...");

  if(devMode) { watch(); }

  var thisPromise = transpilePromise = new Promise(function(resolve) {

    var out = {};
    var promise = Promise.resolve();
    var files = glob.sync("/*.{css,less,styl}",{root:options.srcBase});

    files.forEach(function(filePath) {

      var filePromise = (path.extname(filePath) === ".styl") ? transpileStylus(filePath,devMode,opts) : transpileLess(filePath,devMode,opts);

      promise = promise.then(function() {
        return filePromise.then(function(content) {
          out[path.basename(filePath,path.extname(filePath))] = content;
          return true;
        });
      });
    });

    promise.then(function() {
      if(thisPromise === thisPromise) {
        log.info(chalk.cyan("CSS Transpile complete"));
        resolve(out);
      }
      else {
        resolve(transpilePromise);
      }
    });

  });

  return thisPromise;

};

function getAssets() {
  var thisPromise = transpilePromise;
  return transpilePromise.then(function() {
    if(thisPromise === transpilePromise) {
      return transpilePromise;
    }
    return getAssets();
  });
}


module.exports = function(req,res,next) {

  var match = req.path.match(/([a-zA-Z0-9\-\_\.]+)\.css/);
  var name = match && match[1];

  if(!name) { return next(); }

  if(!transpilePromise) {
    transpile(true);
  }

  getAssets().then(function(assets) {
    var asset = assets[name];
    if(asset) {
      res.set("content-type","text/css");
      res.send(asset);
    }
    else {
      next();
    }
  });

};

module.exports.setOptions = function(opts) {
  options = _.merge(options,opts);
};

module.exports.transpile = transpile;

var build = module.exports.build = function(dev,opts) {

  opts = _.merge({},options,opts);
  _.merge(opts,opts[dev ? "dev" : "prod"]);

  var promise = transpile(dev,opts);
  mkdirp(opts.destination,function() {
    promise.then(function(files) {
      _.forEach(files,function(content,name) {
        var filePromise = new Promise(function(resolve,reject) {
          fs.writeFile(path.resolve(opts.destination,name + ".css"),content,function(err) {
            if(err) { reject(err); }
            else { resolve(); }
          });
        });
        promise = promise.then(function() { return filePromise; });
      });
    });
  });
  return promise;
};

module.exports.gulp = function(dev,opts) {
  return function() {
    return build(dev,opts);
  };
};
