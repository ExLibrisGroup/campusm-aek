log = require("../logger")
Promise = require("rsvp").Promise
npm = require "../npm"
config = require "../config"
request = require("request")
htmlEncoder = new require("node-html-encoder").Encoder("entity")
yaml = require("js-yaml")
inspect = require("eyes").inspector()
chalk = require("chalk")
cookie = require("cookie")

express = require("express")
path = require("path")
app = express()
httpProxy = require("http-proxy")
_ = require("lodash")
fs = require("fs")
URL = require("url")
crypto = require("crypto")

morgan = require("morgan")
cookieParser = require("cookie-parser")

expressSession = require("express-session")

auth = require("../auth")
utils = require("../utils")

pkgOmbiel = require("../fstore")("./package.json","ombiel")


screenBasePath = path.resolve("./screens")
if !fs.existsSync(screenBasePath)
  screenBasePath = path.resolve("./.build/screens")

screenDir = path.resolve(screenBasePath,"dev")

if !fs.existsSync(screenDir)
  screenDir = screenBasePath  

glob = require("glob")


getUserDetails = auth.getUserDetails

getScreenHashes = (screens,cb)->
  fs.readFile "./package.json",(err,pkgContent)->
    if err or !pkgContent 
      return cb(err ? Error("No content in package.json"),{})
    try
      pkgContent = JSON.parse(pkgContent)
    catch e
      return cb(Error("Failed to parse package.json"),{})
    pkgName = pkgContent.name

    if !pkgName
      return cb(Error("Package has no name"),{})

    pkgName = pkgName.replace(/^\@ombiel\//,"")

    pkgData = {name:pkgName,version:pkgContent.version}
    for screen in _.values(screens)
      screen.path = pkgName + "/" + screen.name
      hash = crypto.createHash("md5")
      hash.update(screen.path)
      screen.hash = "aek"+hash.digest("hex").substring(0,17)
      screens[screen.hash] = screen
    
    cb(null,{pkgData,screens})

getDevScreens = (req,res,cb)->
      
    fs.readdir screenDir,(err,files)->
      screens = {}
      if files
        for filename in files
          do(filename)->
            screen = name:filename.split(".")[...-1].join(".")
            screens[screen.name] = screen
      
      getScreenHashes _.extend({},screens,req.screens),cb
      

    
    

    
    
IDs = 
  menu:
    attr:"code"
    clone:"desc"

timestamp = Date.now()

module.exports =
  name:"runserver"
  help:"Run development server."

  options:[
    {
      name:"port"
      default:process.env.PORT || "5000"
    }
    {
      name:"username"
      message:"Please enter your App Manager username"
      noPrompt:true
    }
    {
      name:"password"
      message:"Please enter your App Manager password"
      inputType:"password"
      noPrompt:true
    }
    {
      name:"hostname"
      message:"Which hostname would you like to target"
      promptIfMissing:true
      beforeInquiry:(opts,data)->
        devHostname = pkgOmbiel.get("dev.hostname") || pkgOmbiel.get("runserver.hostname")
        if devHostname
          return Promise.resolve _.extend({},opts,{value:devHostname})

        
        return auth.getOptionHostnames(opts,data)
    }
    {
      name:"targetProtocol"
      default:pkgOmbiel.get("runserver.targetProtocol") || "https"
      noPrompt:true
    }
    {
      name:"targetPort"
      default:pkgOmbiel.get("runserver.targetPort")
      noPrompt:true
    }
    {
      name:"appManagerBase"
      noPrompt:true
      default:pkgOmbiel.get("appManager.baseURL")
    }
    {
      name:"bypassSSLVerification"
      noPrompt:true
      default:pkgOmbiel.get("appManager.bypassSSLVerification") || false
    }
    {
      name:"logs"
      noPrompt:true
      default:false
    }
    {
      name:"useProxy"
      noPrompt:true
      default:process.env.HTTP_PROXY || false
    }
    
  ]

  callback:(options)->
    
    token = null
    username = null

    conf = {}
    configPath = "./runserver.yaml"

    reloadConfig = (cb)->
      fs.readFile configPath,(err,data)->
        if !data
          log.warn "runserver.yaml config not found"
          
        else
          try
            newConf = yaml.load(data.toString())
          catch e
            log.error "Error parsing runserver.yaml"
            inspect(e)

        if newConf
          conf = newConf
          log.info "new runserver.yaml config applied"

        else
          conf = {}

        cb?()


    reloadConfig ()->

      fs.watchFile configPath,reloadConfig

      # renew token every 5 mins
      setInterval ()->
        auth.renew().then (obj)->
          token = obj.token
      ,5000*60

      getUserDetails(options)
        .then (userDetails)->
          username = userDetails.username
          token = userDetails.token
          dc = utils.getDC(username)
          
          if userDetails.apps=="all" || options.hostname in _.pluck(userDetails.apps,"hostname")
            targetProtocol = options.targetProtocol?.match(/https?/)?[0] || "https"
            hostname = options.hostname
            targetPort = parseInt(options.targetPort?.toString().match(/\d+/)?[0])
            targetBaseURL = targetProtocol + "://" + hostname + (targetPort && ":"+targetPort || "")
          
            app.set "port", options.port
            
            if options.logs
              app.use morgan("dev")
            
            app.use (req,res,next)->
              if req.url.match(/^\/c\//)
                req.url = "/aek" + req.url
              next()

            for route,plugin of conf.plugins
              requirePath = plugin
              if plugin.indexOf("-/")==0
                requirePath = path.resolve("./",plugin.substr(2))
              log.info "Plugin '#{chalk.cyan(route)}' installed #{chalk.grey(plugin)}"
              app.use(route,require(requirePath))



            app.use "/public/dev",(req,res)->
              res.send(404,"You cannot access '/public/dev' directly - access via '/public' instead")

            app.use "/public/prod",(req,res)->
              res.send(404,"You cannot access '/public/prod' directly - access via '/public' instead")

            app.use "/public/allenv",(req,res)->
              res.send(404,"You cannot access '/public/allenv' directly - access via '/public' instead")

            
            if glob.sync("public/*(allenv|dev|prod)").length
              
              app.use "/public",express.static('public/dev',{})
              app.use "/public",express.static('public/allenv',{})
              app.use "/public",express.static('public/prod',{})
            
            else 
              app.use "/public",express.static('public',{})

            app.use cookieParser("popgoestheweasel123987456")
            app.use expressSession({secret: 'whyinever34598277II!',resave:true,saveUninitialized:true})
            
            
            # intercept appcache manifest to stop caching accross hostnames
            app.get "/campusm/*.appcache",(req,res,next)->
              res.status(404);
              res.send("AppCache Disabled for DEV environment")
              # in order to modify the returned data, we need to switch any compression off - we flag it here and apply it later in the proxy request
              # req.preventCompression = true
              # 
              # # hijack writeHead to prevent content-length header
              # setHeader = res.setHeader.bind(res)
              # res.setHeader = (name,value,args...)->
              #   unless name.toLowerCase() == "content-length"
              #     setHeader(name,value,args...)
              # 
              # # now we hijack the responses `write` method in order to buffer the content and modify it
              # write = res.write.bind(res)
              # res.write = (body)->
              #   res.body ?= ""
              #   res.body += body.toString() 
              # end = res.end.bind(res)
              # res.end = ()->
              #   body = """
              #   CACHE MANIFEST
              #   # #{Date.now()}
              # 
              #   # Resources that require the user to be online.
              #   NETWORK:
              #   *
              #   """
              #   write(body)
              #   end()
              # 
              # next()
            
            # intercept startup requests to inject test data if `homepage` section present in conf 
            app.use "/campusm/startupmep/:profileID",(req,res,next)->
              if conf.homepage

                # remove query string and preventCache so we always get fresh data
                # set a flag here and remove at proxy
                # todo: improve and optimise this by maintaining local cache
                req.removeQueryString = true
                req.preventCache = true
                
                # in order to modify the returned data, we need to switch any compression off - we flag it here and apply it later in the proxy request
                req.preventCompression = true
                

                # hijack writeHead to prevent content-length header
                setHeader = res.setHeader.bind(res)
                res.setHeader = (name,value,args...)->
                  unless name.toLowerCase() == "content-length"
                    setHeader(name,value,args...)

                # now we hijack the responses `write` method in order to buffer the content and modify it
                write = res.write.bind(res)
                res.write = (body)->
                  res.body ?= ""
                  res.body += body.toString() 
                end = res.end.bind(res)
                res.end = ()->
                  startup = JSON.parse(res.body)

                  homepageConf = conf.homepage

                  menuItems = (homepageConf.menu?.replace ? []).concat(homepageConf.menu?.append ? [])

                  for menuItem in menuItems
                    do(menuItem)->
                      if menuItem.devPath
                        menuItem.menuRefCode = menuItem.code
                        menuItem.aekCode = "AEK"
                        homepageConf.webUIComponents ?= {}
                        webUIComponents = homepageConf.webUIComponents.append ? (homepageConf.webUIComponents.append = [])
                        webUIComponents.push({menuRefCode:menuItem.code,path:menuItem.devPath})
                        homepageConf.aekToolbars ?= {}
                        aekToolbars = homepageConf.aekToolbars?.append ? (homepageConf.aekToolbars.append = [])
                        aekToolbars.push({code:menuItem.code,items:[{webUIMDCode:menuItem.code}]})

                        
                  # MODIFY STARTUP HERE
                  for key,value of homepageConf
                    target = startup
                    if key in ["stylesheets","scripts"]
                      startup.web2Data ?= {}
                      target = startup.web2Data
                    if value.merge
                      target[key] = _.merge({},target[key],value.merge)
                    if value.replace
                      target[key] = value.replace
                    if value.append
                      target[key] = target[key] || []
                      target[key] = target[key].concat(value.append)
                    if IDs[key]
                      target[key]?.forEach (item)->
                        item[IDs[key].attr] ?= IDs[key].clone && item[IDs[key].clone] || _.uniqueId()


                  write(JSON.stringify(startup))
                  end()

              next()


            screenCache = {}
            previews = {}
            
            proxyOpts = {changeOrigin:true}
            
            if options.useProxy
              proxyURL = URL.parse(options.useProxy)
              tunnel = require("../lib/tunnel")
              proxyOpts.agent = tunnel[proxyURL.protocol == "https" && "httpsOverHttps" || "httpsOverHttp"]
                # maxSockets: poolSize, // Defaults to 5
                rejectUnauthorized:!options.bypassSSLVerification
                proxy:
                  host:proxyURL.hostname || "localhost"
                  port:proxyURL.port || 8888
                  rejectUnauthorized:!options.bypassSSLVerification
            
            proxy = httpProxy.createProxyServer(proxyOpts)

            proxy.on "error",(args...)->
              #  not sure what to do here - we need to supress errors that occur when changing apps and using the same hostname (ie localhost)
              #  but supressing these may have other side effects
              # console.log("ERROR",args)


            # modify request that's proxied  
            proxy.on 'proxyReq', (proxyReq, req, res, options)->
              # if this request has been flagged for no compression, we remove the header in the proxied request
              # this is so we can easily modify the returned data


              if req.removeQueryString
                proxyReq.path = proxyReq.path.split("?")[0]
              


            app.use (req,res,next)->
              parsedURL = URL.parse(req.url)
              
              if (screenName = previews[parsedURL.pathname]) 
                res.redirect("/aek/c/"+screenName)
              
              else
                
                # if the original request is not secure, we need to remove the secure flags on all the cookies
                isSecure = (req.protocol is "https") or (req.headers['x-forwarded-proto'] is 'https')            
                
              
                
                res.oldSetHeader = res.setHeader
                
                res.setHeader = (name, value)->
                  if name.toLowerCase() is "set-cookie"
                    if not _.isArray(value)
                      value = [value]
                    if not isSecure
                      value = _.map value,(cookie)->
                        cookie.replace("; secure","")
                    if !_.find(value,(c)->c.indexOf("aekt_hostname")==0)
                      value = value.concat(cookie.serialize("aekt_hostname",hostname,maxAge:(1000 * 60 * 60 * 24 * 365),path:"/"))
                  
                  res.oldSetHeader(name, value)

                

                proxyRequest = (newPath)->
                  
                  if newPath
                    
                    if req.path.match(/^\/campusm\/sso\/required/i)
                      newPath = "/campusm/sso/required" + newPath
                    else if req.path.match(/^\/campusm\/sso/i)
                      newPath = "/campusm/sso" + newPath
                    
                    req.url = newPath + (parsedURL.search ? "")
                  
                    if req.url.indexOf("?")>-1
                      req.url += "&"
                    else 
                      req.url += "?"
                  
                    req.url += "_ombl_script_name="+encodeURIComponent(parsedURL.pathname)
                  

                  proxyOptions = 
                    changeOrigin:true
                    target:targetBaseURL
                    secure:targetProtocol=="https"
                    headers:{}
                    
                  if req.preventCache
                    proxyOptions.headers['cache-control'] = ''
                    proxyOptions.headers['if-none-match'] = ''

                  if req.preventCompression
                    proxyOptions.headers['Accept-Encoding'] = ''
                  

                  proxy.web req,res,proxyOptions
                
                if req.cookies.aekt_hostname != hostname
                  delete req.headers['cookie']
                  for i of req.cookies
                    res.clearCookie(i)
                
                
                screenName = req.path.match(/\/aek(\/[a-zA-Z0-9\-\_]+\/[a-zA-Z0-9\-\_]+)?\/c\/([a-zA-Z0-9\-\_]+)/)?[2]

                if screenName
                  getDevScreens req,res,(err,{screens,pkgData})->

                    if err
                      log.error "Error getting screens",err
                      next()
                    
                    else

                      devScreen = screens[screenName]
                      if devScreen
                        screenName = devScreen.name
                        
                      getContent = (cb)->
                        if devScreen?.content
                          cb(null,devScreen.content)
                        else
                          screenPath = path.resolve(screenBasePath,"dev",screenName+".twig")

                          if !fs.existsSync(screenPath)
                            screenPath = path.resolve(screenBasePath,screenName+".twig")
                        
                          if !fs.existsSync(screenPath)
                            screenPath = path.resolve(screenBasePath,"prod",screenName+".twig")

                          if fs.existsSync(screenPath)
                            fs.readFile screenPath,(err,data)->
                              cb(err,data.toString())
                          else
                            cb(Error("No Screen found"))
                      
                      getContent (err,content)->
                        if content
                          cache = screenCache[screenName] ? {}
                          if content == cache.source
                            proxyRequest(cache.url)
                          else
                            source = content.replace("[[__package_data__]]",htmlEncoder.htmlEncode(JSON.stringify(_.extend({},pkgData,screen:screenName))))
                              .replace(/\[\[__public_assets__\]\]/g,"/public")
                            
                            if devScreen?.offline
                              res.set("content-type","text/html")
                              res.send(source)
                              return

                            request.post (options.appManagerBase || dc.appManagerBase)+ "/aek/tools/save_preview",
                              strictSSL:!options.bypassSSLVerification
                              form:
                                source:source
                                username:dc.username
                                token:token
                                hostname:hostname
                              (err,am_response,am_body)->
                                try
                                  parsedResponse = JSON.parse(am_body)
                                catch e
                                  res.send(500,{error:"Unable to retreive preview screen from server"})
                                  log.error e,am_body
                                  return
                                
                                cache.url = parsedResponse.url.replace targetBaseURL,""
                                cache.source = source
                                screenCache[screenName] = cache
                                previews[cache.url] = screenName
                              
                                proxyRequest(cache.url)
                        else
                          proxyRequest()
                  return
                
                proxyRequest()

            app.listen app.get("port"), ->
              log.info "AEK proxy server targetting #{hostname}, listening on port " + app.get("port")

        .catch (e)->
          log.error(e)



    # return true
