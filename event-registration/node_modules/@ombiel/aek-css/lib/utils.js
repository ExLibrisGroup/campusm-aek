"use strict";

var gulp = require("gulp"),
    gulpClean = require("gulp-clean"),
    Promise = require("rsvp").Promise;

// function returns a promise which is resolved after deleting files that match a given glob
function clean(src) {
  return new Promise(function(resolve,reject) {
    gulp.src(src,{read:false})
      .pipe(gulpClean())
      .on('end',resolve)
      .on('error',reject)
      .resume();
  });
}

// function to extract sections from semantic less source
function getSemanticSection(src,section,major,minor,sub) {
  var re,match,content = src;
  if(section) {
    re = new RegExp("(\\/\\*\\*+\\n\\s*"+section+"\\s*\\n\\*\\*+\\*\\/(.|\\n)*?(?=(\\/\\*\\*+\\n)|$))","i");
    match = content.match(re);
    content = match && match[1] || "";
  }
  
  if(major) {
    re = new RegExp("(\\/\\*\\-+\\n\\s*"+major+"\\s*\\n\\-+\\*\\/(.|\\n)*?(?=(\\/\\*\\-+\\n)|$))","i");
    match = content.match(re);
    content = match && match[1] || "";
  }
  if(minor) {
    re = new RegExp("(\\/\\*\\-{3}\\s*"+minor+"\\s*\\-{3}\\*\\/(.|\\n)*?(?=(\\/\\*\\-{3})|$))","i");
    match = content.match(re);
    content = match && match[1] || "";
  }
  if(sub) {
    re = new RegExp("(\\/\\*\\s*"+sub+"\\s*\\*\\/(.|\\n)*?(?=(\\/\\*)|$))","i");
    match = content.match(re);
    content = match && match[1] || "";
  }
  return content;
}


function removeSemanticSection(src,section,major,minor,sub) {
  var content = getSemanticSection(src,section,major,minor,sub);
  
  if(content) {
    // console.log(chalk.yellow("removing..."));
    // console.log(chalk.grey(content));
    src = src.replace(content,"");
  }
  return src;
}

function reRule(selector) {
  var reg = new RegExp("(\\.u)?i(\\.(\\n|[a-z0-9\\.\\s\\[\\]\\-\\:\\,\\>\\(\\)])*)?"+selector+"(\\n|[a-z0-9\\.\\s\\[\\]\\-\\:\\,\\>\\(\\)])*\\s\\{(\\n|.)*?\\}","gi");
  return reg;
}

module.exports = {
  clean:clean,
  getSemanticSection:getSemanticSection,
  removeSemanticSection:removeSemanticSection,
  reRule:reRule
};
