var React = require("react");
var utils = require("../../utils");
var Field = require("./field");
var {Padding} = require("./segment");
var React = require("react");
var mergeProps = require("../utils/merge-props");
var Panel = require("./panel");
var Pager = require("./pager");
var Page = require("./page");

var _ = utils;



var FormBody = React.createClass({

  render:function() {

    var elementCount = 0;

    var body = [];
    var fields = this.props.fields || [];
    fields.forEach(function(field) {
      if(_.isArray(field)) {
        body = body.concat(field.map((element)=>{
          if(element.key) { return element; }
          else { return React.cloneElement(element,{key:("el" + (elementCount++))}); }
        }));
      }
      else {
        body.push(<Field ref={field.name} {...field}/>);
      }
    });

    return <div>{body}</div>;

  }
});


var Form = React.createClass({

  getDefaultProps:function() {
    return {bodyComponent:FormBody};
  },

  onChange:function(e,name,value) {
    if(this.props.onChange) {
      // for some unknown reason this is getting fired twice, the second time, it gives an undefined value
      // can't see a legitimate reason for having an undefined value so ignore them
      if(value !== undefined) {
        this.props.onChange(e,name,value,this);
      }
    }

  },

  focus:function(fieldName) {
    this.getDOMNode().querySelector(`[name='${fieldName}']`).focus();
  },

  render:function() {
    var form = this;
    var data = utils.extend({},(this.props.data || {}));

    var {messages} = this.props.validation || {valid:true,messages:{}};

    var fields = this.props.fields.map(function(field) {
      if(_.isArray(field)) { return field; }
      field = utils.extend({},field);
      if(field.hideLabel === undefined) {
        field.hideLabel = field.label === false;
      }
      field.label = field.label || utils.titleCase(field.name);
      if(field.value === undefined) {
        field.value = data[field.name] || "";
      }
      field.validation = field.validation || messages[field.name];
      field.onChange = field.onChange || form.onChange;

      if(!field.key) { field.key = field.name; }

      return field;
    });

    var content,transitionDirection;

    if(this.props.useSubpageFields) {

      var ctx = this.props.ctx;

      if(ctx) {
        transitionDirection = ctx.transitionDirection;
        if(this.props.ctx.query.formField) {
          var currentField = _.findWhere(fields,{name:this.props.ctx.query.formField});
          if(currentField && currentField.type && currentField.type.Handler) {
            content = React.createElement(currentField.type.Handler,{form:this,field:currentField,key:currentField.name});
          }
        }
      }
    }

    if(!content) {
      var body = null;

      var bodyProps = mergeProps(this.props,{form,fields,key:"formBody"});

      body = React.createElement(this.props.bodyComponent,bodyProps);

      content = [
        this.props.formTop,
        body,
        this.props.formBottom
      ];

      if(this.props.useSubpageFields) {
        content = <Page key="mainForm"><Padding>{content}</Padding></Page>;
      }
    }

    if(this.props.useSubpageFields) {

      return (
        <Panel key="form" component="form" className="ui form" onSubmit={this.onSubmit}>
          <Pager key="form" transitionDirection={transitionDirection}>
            {content}
          </Pager>
        </Panel>
      );
    }

    return <form className="ui form" onSubmit={this.onSubmit}>{content}</form>;

  },

  onSubmit:function(e) {
    e.preventDefault();
    if(this.props.onSubmit) {
      this.props.onSubmit(e);
    }
  }

});


module.exports = Form;
