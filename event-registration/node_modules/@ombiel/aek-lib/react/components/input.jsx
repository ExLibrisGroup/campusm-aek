var React = require("react");
var mergeProps = require("../utils/merge-props");
var pickHtmlProps = require("../utils/pick-html-props");
var getChildren = require("../utils/children");
var {Label,Tag,Corner} = require("./label");
var Button = require("./button");
var _ = require("../../utils");


function isButton(component) {
  return _.contains([Button],component.type);
}

function isLabel(component) {
  return _.contains([Label,Tag,Corner],component.type);
}

function isInput(component) {
  return _.contains(["input","textarea"],component.type);
}

var Input = React.createClass({

  getDefaultProps:function() {
    return {
      containerComponent:"div",
      type:"text"
    };
  },

  focus:function() {
    var input = this.refs.input;
    if(input) {
      input.getDOMNode().focus();
    }
  },

  render:function() {

    var props = this.props;
    var component = props.component || (props.type === "textarea" && "textarea") || "input";
    var containerProps = {classSet:{ui:true,input:true}};
    var inputProps = {classSet:{}};
    var children = getChildren(this);


    // container states
    ["loading","error","transparent","inverted","fluid"].forEach(function(prop) {
      if(props[prop]) { containerProps.classSet[prop] = true; }
    });

    if(props.size) {
      containerProps.classSet[props.size] = true;
    }



    // icons
    var iconLeft,iconRight;

    // if loading, needs an icon as a placeholder
    if(!props.icon && props.loading) {
      props.icon = "circle";
    }

    if(props.icon) {
      var iconProps = mergeProps({className:props.icon+" icon"},props.iconProps);
      var icon = <i key="icon" {...iconProps}/>;
      if(props.iconLeft) {
        iconLeft = icon;
      }
      else {
        iconRight = icon;
      }
    }


    inputProps = mergeProps(inputProps,props,{key:"input",children:null});

    if (_.isString(component)) {
      if (component === "input") {
        inputProps = pickHtmlProps(inputProps,{exclude:["children"]});
      }
      else {
        inputProps = pickHtmlProps(inputProps);
      }

    }

    var input = React.createElement(component,inputProps);
    var hasInput,labelRight,buttonRight;


    var content = children.filter(function(child) {

      if(isLabel(child)) {
        containerProps.classSet.right = hasInput;
        if(child.type === Corner) {
          if(hasInput) {
            containerProps.classSet.corner = true;
          }
          else {
            containerProps.classSet["left corner"] = true;
          }
        }
        containerProps.classSet.labeled = true;
        labelRight = !!hasInput;
        return true;
      }

      if(isButton(child)) {
        if(!hasInput) {
          containerProps.classSet["left action"] = true;
        }
        else {
          containerProps.classSet.action = true;
        }
        buttonRight = !!hasInput;
        return true;
      }

      if(isInput(child)) {
        hasInput = true;
        return true;
      }

    }).map(function(child) {

      if( !child.type ) { return child; }

      if(child.type === Corner && !containerProps.classSet.right) {
        return React.cloneElement(child,{className:"left"});
      }

      if(child.type === "input" || child.type === "textarea") {
        hasInput = true;
        return [iconLeft,React.cloneElement(input,mergeProps(input.props,{ref:"input"},child.props)),iconRight];
      }

      return React.cloneElement(child,{key:isButton(child) && "button" || "label"});
    });

    if(!hasInput) { content = content.concat([iconLeft,input,iconRight]); }

    if(props.icon) {
      if((labelRight || buttonRight) || (props.iconLeft && labelRight !== false && buttonRight !== false)) {
        containerProps.classSet["left icon"] = true;
      }
      else {
        containerProps.classSet.icon = true;
      }

    }

    containerProps = mergeProps(containerProps,props.containerProps);

    if (_.isString(props.containerComponent)) {
      containerProps = pickHtmlProps(containerProps);
    }

    return React.createElement(props.containerComponent,containerProps,content);

  }

});


module.exports = Input;
