// Generated by CoffeeScript 1.6.3
(function() {
  var Actor, Commit, Config, Diff, Head, Ref, Repo, Status, Tag, Tree, cmd, _, _ref;

  _ = require('underscore');

  cmd = require('./git');

  Actor = require('./actor');

  Commit = require('./commit');

  Config = require('./config');

  Tree = require('./tree');

  Diff = require('./diff');

  Tag = require('./tag');

  Status = require('./status');

  _ref = require('./ref'), Ref = _ref.Ref, Head = _ref.Head;

  module.exports = Repo = (function() {
    function Repo(path, bare) {
      this.path = path;
      this.bare = bare;
      if (this.bare) {
        this.dot_git = this.path;
      } else {
        this.dot_git = "" + this.path + "/.git";
      }
      this.git = cmd(this.path, this.dot_git);
    }

    Repo.prototype.identity = function(callback) {
      var _this = this;
      return this.git("config", {}, ["user.email"], function(err, stdout) {
        var email;
        if (stdout == null) {
          stdout = '';
        }
        if (err) {
          return callback(err);
        }
        email = stdout != null ? stdout.trim() : void 0;
        return _this.git("config", {}, ["user.name"], function(err, stdout) {
          var name;
          if (stdout == null) {
            stdout = '';
          }
          if (err) {
            return callback(err);
          }
          name = stdout != null ? stdout.trim() : void 0;
          return callback(null, new Actor(name, email));
        });
      });
    };

    Repo.prototype.identify = function(actor, callback) {
      var _this = this;
      return this.git("config", {}, ["user.email", "\"" + actor.email + "\""], function(err) {
        if (err) {
          return callback(err);
        }
        return _this.git("config", {}, ["user.name", "\"" + actor.name + "\""], function(err) {
          if (err) {
            return callback(err);
          }
          return callback(null);
        });
      });
    };

    Repo.prototype.commits = function(start, limit, skip, callback) {
      var options, _ref1, _ref2, _ref3;
      if (!callback) {
        _ref1 = [callback, skip], skip = _ref1[0], callback = _ref1[1];
      }
      if (!callback) {
        _ref2 = [callback, limit], limit = _ref2[0], callback = _ref2[1];
      }
      if (!callback) {
        _ref3 = [callback, start], start = _ref3[0], callback = _ref3[1];
      }
      if (!callback) {
        throw new Error("a callback is required");
      }
      if (start == null) {
        start = "master";
      }
      if (limit == null) {
        limit = 10;
      }
      if (skip == null) {
        skip = 0;
      }
      options = {
        skip: skip
      };
      if (limit !== -1) {
        options["max-count"] = limit;
      }
      return Commit.find_all(this, start, options, callback);
    };

    Repo.prototype.current_commit_id = function(callback) {
      var _this = this;
      return this.git("rev-parse HEAD", {}, [], function(err, stdout, stderr) {
        if (err) {
          return callback(err);
        }
        return callback(null, _.first(stdout.split("\n")));
      });
    };

    Repo.prototype.current_commit = function(callback) {
      var _this = this;
      return this.current_commit_id(function(err, commit_id) {
        if (err) {
          return callback(err);
        }
        return Commit.find(_this, commit_id, callback);
      });
    };

    Repo.prototype.tree = function(treeish) {
      if (treeish == null) {
        treeish = "master";
      }
      return new Tree(this, treeish);
    };

    Repo.prototype.diff = function(commitA, commitB) {
      var callback, options, paths, _ref1, _ref2,
        _this = this;
      _ref1 = [[], {}], paths = _ref1[0], options = _ref1[1];
      if (arguments.length === 3) {
        callback = arguments[2];
      } else if (arguments.length === 4) {
        callback = arguments[3];
        if (arguments[2] instanceof Array) {
          paths = arguments[2];
        } else if (arguments[2] instanceof Object) {
          options = arguments[2];
        }
      } else if (arguments.length === 5) {
        _ref2 = Array.prototype.slice.call(arguments, 2), paths = _ref2[0], options = _ref2[1], callback = _ref2[2];
      }
      if (_.isObject(commitA)) {
        commitA = commitA.id;
      }
      if (_.isObject(commitB)) {
        commitB = commitB.id;
      }
      return this.git("diff", options, _.flatten([commitA, commitB, "--", paths]), function(err, stdout, stderr) {
        if (err) {
          return callback(err);
        }
        if (_.has(options, 'raw')) {
          return callback(err, Diff.parse_raw(_this, stdout));
        } else {
          return callback(err, Diff.parse(_this, stdout));
        }
      });
    };

    Repo.prototype.remotes = function(callback) {
      return Ref.find_all(this, "remote", Ref, callback);
    };

    Repo.prototype.remote_list = function(callback) {
      return this.git.list_remotes(callback);
    };

    Repo.prototype.remote_add = function(name, url, callback) {
      return this.git("remote", {}, ["add", name, url], function(err, stdout, stderr) {
        return callback(err);
      });
    };

    Repo.prototype.remote_remove = function(name, callback) {
      return this.git("remote", {}, ["rm", name], function(err, stdout, stderr) {
        return callback(err);
      });
    };

    Repo.prototype.remote_add_url = function(name, url, callback) {
      return this.git("remote set-url", {}, ["--add", name, url], function(err, stdout, stderr) {
        return callback(err);
      });
    };

    Repo.prototype.remote_set_url = function(name, url, callback) {
      return this.git("remote set-url", {}, [name, url], function(err, stdout, stderr) {
        return callback(err);
      });
    };

    Repo.prototype.remote_delete_url = function(name, url, callback) {
      return this.git("remote set-url", {}, ["--delete", name, url], function(err, stdout, stderr) {
        return callback(err);
      });
    };

    Repo.prototype.remote_fetch = function(name, callback) {
      return this.git("fetch", {}, name, function(err, stdout, stderr) {
        return callback(err);
      });
    };

    Repo.prototype.remote_push = function(name, branch, callback) {
      var args;
      if (!callback) {
        callback = branch;
        args = name;
      } else {
        args = [name, branch];
      }
      return this.git("push", {}, args, function(err, stdout, stderr) {
        return callback(err);
      });
    };

    Repo.prototype.merge = function(name, callback) {
      return this.git("merge", {}, name, function(err, stdout, stderr) {
        return callback(err);
      });
    };

    Repo.prototype.status = function(options, callback) {
      var _ref1;
      if (!callback) {
        _ref1 = [callback, options], options = _ref1[0], callback = _ref1[1];
      }
      return Status(this, options, callback);
    };

    Repo.prototype.ls_files = function(options, callback) {
      var _ref1,
        _this = this;
      if (!callback) {
        _ref1 = [callback, options], options = _ref1[0], callback = _ref1[1];
      }
      return this.git("ls-files", options, function(err, stdout, stderr) {
        if (err) {
          return callback(err);
        }
        return callback(null, _this.parse_lsFiles(stdout, options));
      });
    };

    Repo.prototype.config = function(callback) {
      return Config(this, callback);
    };

    Repo.prototype.tags = function(callback) {
      return Tag.find_all(this, callback);
    };

    Repo.prototype.create_tag = function(name, options, callback) {
      var _ref1;
      if (!callback) {
        _ref1 = [callback, options], options = _ref1[0], callback = _ref1[1];
      }
      return this.git("tag", options, [name], callback);
    };

    Repo.prototype.delete_tag = function(name, callback) {
      return this.git("tag", {
        d: name
      }, callback);
    };

    Repo.prototype.branches = function(callback) {
      return Head.find_all(this, callback);
    };

    Repo.prototype.create_branch = function(name, callback) {
      return this.git("branch", {}, name, function(err, stdout, stderr) {
        return callback(err);
      });
    };

    Repo.prototype.delete_branch = function(name, callback) {
      return this.git("branch", {
        d: true
      }, name, function(err, stdout, stderr) {
        return callback(err);
      });
    };

    Repo.prototype.branch = function(name, callback) {
      var _ref1;
      if (!callback) {
        _ref1 = [callback, name], name = _ref1[0], callback = _ref1[1];
      }
      if (!name) {
        return Head.current(this, callback);
      } else {
        return this.branches(function(err, heads) {
          var head, _i, _len;
          if (err) {
            return callback(err);
          }
          for (_i = 0, _len = heads.length; _i < _len; _i++) {
            head = heads[_i];
            if (head.name === name) {
              return callback(null, head);
            }
          }
          return callback(new Error("No branch named '" + name + "' found"));
        });
      }
    };

    Repo.prototype.checkout = function(treeish, callback) {
      return this.git("checkout", {}, treeish, callback);
    };

    Repo.prototype.clean = function(options, callback) {
      if (options == null) {
        options = {};
      }
      return this.git("clean", options, callback);
    };

    Repo.prototype.reset = function(treeish, options, callback) {
      var _ref1, _ref2, _ref3;
      if (!callback) {
        _ref1 = [callback, options], options = _ref1[0], callback = _ref1[1];
      }
      if (!callback) {
        _ref2 = [callback, treeish], treeish = _ref2[0], callback = _ref2[1];
      }
      if (typeof treeish === 'object') {
        _ref3 = [options, treeish], treeish = _ref3[0], options = _ref3[1];
      }
      if (treeish == null) {
        treeish = 'HEAD';
      }
      if (options == null) {
        options = {};
      }
      return this.git("reset", options, treeish, callback);
    };

    Repo.prototype.checkoutFile = function(files, options, callback) {
      var _ref1, _ref2, _ref3;
      if (!callback) {
        _ref1 = [callback, options], options = _ref1[0], callback = _ref1[1];
      }
      if (!callback) {
        _ref2 = [callback, files], files = _ref2[0], callback = _ref2[1];
      }
      if (typeof files === 'object') {
        _ref3 = [options, files], files = _ref3[0], options = _ref3[1];
      }
      if (options == null) {
        options = {};
      }
      if (files == null) {
        files = '.';
      }
      if (_.isString(files)) {
        files = [files];
      }
      return this.git("checkout", options, _.flatten(['--', files]), callback);
    };

    Repo.prototype.commit = function(message, options, callback) {
      var _ref1;
      if (!callback) {
        _ref1 = [callback, options], options = _ref1[0], callback = _ref1[1];
      }
      if (options == null) {
        options = {};
      }
      options = _.extend(options, {
        m: "\"" + message + "\""
      });
      if (options.author != null) {
        options.author = "\"" + options.author + "\"";
      }
      return this.git("commit", options, callback);
    };

    Repo.prototype.add = function(files, options, callback) {
      var _ref1;
      if (!callback) {
        _ref1 = [callback, options], options = _ref1[0], callback = _ref1[1];
      }
      if (options == null) {
        options = {};
      }
      if (_.isString(files)) {
        files = [files];
      }
      return this.git("add", options, files, callback);
    };

    Repo.prototype.remove = function(files, options, callback) {
      var _ref1;
      if (!callback) {
        _ref1 = [callback, options], options = _ref1[0], callback = _ref1[1];
      }
      if (options == null) {
        options = {};
      }
      if (_.isString(files)) {
        files = [files];
      }
      return this.git("rm", options, files, callback);
    };

    Repo.prototype.revert = function(sha, callback) {
      return this.git("revert", {}, sha, callback);
    };

    Repo.prototype.sync = function(remote_name, branch_name, callback) {
      var branch, remote, _ref1, _ref2, _ref3,
        _this = this;
      if (typeof callback === "function") {
        _ref1 = [remote_name, branch_name], remote = _ref1[0], branch = _ref1[1];
      }
      if (typeof branch_name === "function") {
        _ref2 = ["origin", remote_name, branch_name], remote = _ref2[0], branch = _ref2[1], callback = _ref2[2];
      }
      if (typeof remote_name === "function") {
        _ref3 = ["origin", "master", remote_name], remote = _ref3[0], branch = _ref3[1], callback = _ref3[2];
      }
      return this.status(function(err, status) {
        if (err) {
          return callback(err);
        }
        return _this.git("stash", {}, ["save", "-u"], function(err, stdout, stderr) {
          if (err) {
            return callback(stderr);
          }
          return _this.git("pull", {}, [remote, branch], function(err, stdout, stderr) {
            if (err) {
              return callback(stderr);
            }
            return _this.git("push", {}, [remote, branch], function(err, stdout, stderr) {
              if (err) {
                return callback(stderr);
              }
              if (!(status != null ? status.clean : void 0)) {
                return _this.git("stash", {}, ["pop"], function(err, stdout, stderr) {
                  if (err) {
                    return callback(stderr);
                  }
                  return callback(null);
                });
              } else {
                return callback(null);
              }
            });
          });
        });
      });
    };

    Repo.prototype.pull = function(remote_name, branch_name, callback) {
      var branch, remote, _ref1, _ref2, _ref3,
        _this = this;
      if (typeof callback === "function") {
        _ref1 = [remote_name, branch_name], remote = _ref1[0], branch = _ref1[1];
      }
      if (typeof branch_name === "function") {
        _ref2 = ["origin", remote_name, branch_name], remote = _ref2[0], branch = _ref2[1], callback = _ref2[2];
      }
      if (typeof remote_name === "function") {
        _ref3 = ["origin", "master", remote_name], remote = _ref3[0], branch = _ref3[1], callback = _ref3[2];
      }
      return this.status(function(err, status) {
        if (err) {
          return callback(err);
        }
        return _this.git("pull", {}, [remote, branch], function(err, stdout, stderr) {
          if (err) {
            return callback(stderr);
          }
          return callback(null);
        });
      });
    };

    Repo.prototype.parse_lsFiles = function(text, options) {
      var files, line, lines;
      files = [];
      if (_.has(options, 'z')) {
        lines = text.split("\0");
      } else {
        lines = text.split("\n");
      }
      while (lines.length) {
        line = lines.shift().split(" ");
        files.push(line);
        while ((lines[0] != null) && !lines[0].length) {
          lines.shift();
        }
      }
      return files;
    };

    return Repo;

  })();

}).call(this);
