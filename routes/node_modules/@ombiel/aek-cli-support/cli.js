const _ = require("lodash");
const spawnargs = require("spawn-args");
const inquirer = require("inquirer");
const chalk = require("chalk");
const path = require("path");
const fs = require("fs");
const utils = require("./utils");
const {FriendlyError,printNiceError} = require("./nice-error");

const prompt = utils.prompt;

function inquirerOptionsTransform(options,data = {}) {

  // type: (String) Type of the prompt. Defaults: input - Possible values: input, confirm, list, rawlist
  // name: (String) The name to use when storing the answer in the anwers hash.
  // message: (String|Function) The question to print. If defined as a function, the first parameter will be the current inquirer session answers.
  // default: (String|Number|Array|Function) Default value(s) to use if nothing is entered, or a function that returns the default value(s). If defined as a function, the first parameter will be the current inquirer session answers.
  // choices: (Array|Function) Choices array or a function returning a choices array. If defined as a function, the first parameter will be the current inquirer session answers.
  // Array values can be simple strings, or objects containing a name (to display) and a value properties (to save in the answers hash). Values can also be a Separator.
  // validate: (Function) Receive the user input and should return true if the value is valid, and an error message (String) otherwise. If false is returned, a default error message is provided.
  // filter: (Function) Receive the user input and return the filtered value to be used inside the program. The value returned will be added to the Answers hash.
  // when: (Function) Receive the current user answers hash and should return true or false depending on whether or not this question should be asked.



  options = _.clone(options);

  let promise = Promise.resolve(options);

  if (options.beforeInquiry) {
    promise = options.beforeInquiry(options,data);
  }


  return promise.then(function(opts) {

    opts.type = opts.inputType
      || (opts.flag && "confirm")
      || (opts.choices && (opts.list ? "checkbox" : "list"))
      || (opts.list && "rawlist")
      || "input";

    delete opts.transform;
    delete opts.filter;

    if (!opts.message) {
      if (opts.help && _.isFunction(opts.help)) {
        opts.message = function() {
          const helpPromise = utils.runPromise(opts.help);
          const done = this.async();
          helpPromise.then(done);
        };
      }
      else {
        opts.message = opts.help || `Please enter value for ${opts.name}`;
      }
    }

    ["message","default","choices"].forEach(function(opt) {
      if (_.isFunction(opts[opt])) {
        const orig = opts[opt];
        opts[opt] = function() {
          return orig.call(this,data);
        };
      }
    });

    return opts;
  });
}



function nomnomOptionsTransform(opts,data = {}) {

  // abbr
  // flag
  // metavar
  // help
  // default
  // type
  // callback
  // position
  // list
  // required
  // choices - needs transforming to string array
  // hidden

  let promise = Promise.resolve();
  opts = _.clone(opts);

  delete opts.transform;
  delete opts.choices;

  if (opts.required && opts.promptIfMissing) {
    delete opts.required;
  }

  if (opts.promptIfMissing) {
    delete opts.default;
  }

  ["help","default"].forEach(function(opt) {

    if (_.isFunction(opts[opt])) {
      promise = promise.then(function() {
        return utils.runPromise(opts[opt],data[opt]).then(function(val) {
          opts[opt] = val;
          return opts;
        });
      });
    }
  });

  promise.then(function() {
    if (opts.required) {
      opts.help = opts.help ? (`${opts.help} `) : "";
      opts.help = chalk.grey(opts.help) + chalk.yellow("(required)");
    }
  });


  return promise.then(function() {
    return opts;
  });
}



class CLI {

  constructor(commands,options = {}) {
    this.options = options;
    this.log = options.log;

    this.finish = this.finish.bind(this);
    this.startSession = this.startSession.bind(this);

    const helpCommand = {
      name: "help",
      help: "get help/usage for command",
      options: [
        {
          name: "helpCommand",
          message: "Choose a command you want help with",
          choices: commands.filter((command)=>!command.nolist).map((command)=>command.name),
          position: 1,
        }
      ],
      callback: (opts)=>{
        const command = opts.helpCommand || "";
        const helpCli = new CLI(commands,this.options);
        helpCli.ready.then(function() {
          helpCli.parse(`${command} --help`);
        });
      },
    };

    this.commands = [helpCommand].concat(commands);

    this.nomnom = require("./lib/nomnom")();

    this.ready = Promise.resolve();


    if (this.options.scriptName) {
      this.nomnom.script(this.options.scriptName);
    }


    this.commands.forEach((command)=>{

      if (command.type === "session") {
        command.callback = this.startSession;
      }
      const com = this.nomnom.command(command.name);
      if (command.options) {
        command.options.forEach((opt)=>{

          if (opt.required && !opt.validate) {
            opt.validate = (val)=>{
              if (_.isArray(val) && val.length === 0) {
                return "Please select at least one option";
              }
              return !!val || "This is not optional, please enter a value";
            };
          }
          this.ready = this.ready.then(()=>nomnomOptionsTransform(opt,{})).then(function(optn) {
            return com.option(optn.name,optn);
          });
        });
      }
      ["help","usage"].forEach((prop)=>{
        if (command[prop]) {
          com[prop] = command[prop];
        }
      });

      com.callback((values)=>{
        return this.processCommand(command,values).catch((err)=>{
          printNiceError(err);
          process.exit(1);
        });
      });
    });

    this.nomnom.nocommand().options({version: {flag: true}}).callback((opts)=>{
      if (opts.version) {

        const versions = {
          "aek-cli-support": JSON.parse(fs.readFileSync(path.resolve(__dirname,"package.json"))).version,
        };

        if (options.getVersion) {
          _.extend(versions,options.getVersion());
        }

        console.log(JSON.stringify(versions,null,2)); // eslint-disable-line no-console

      }
      else {
        this.session = true;
        const question = {
          name: "command",
          message: "Please choose a command to execute",
          type: "list",
          choices: this.commands.reduce(function(choices,command) {
            if (!command.nolist) {
              choices.push({
                name: chalk.bold(command.name) + (command.help ? chalk.grey.italic(` - ${command.help}`) : ""),
                value: command.name,
              });
            }
            return choices;
          },[]),
        };

        inquirer.prompt([question],(answers)=>{
          return this.processCommand(answers.command,{});
        });
      }
    });




    this.nomnom.printer((str,code)=>{
      if (!this.session) {
        console.log(str); //eslint-disable-line no-console
        process.exit(code || 0);
      }
      this.finish();
    });
  }


  finish() {

    if (this.session) {
      this.commandPrompt();
    }
  }

  startSession() {
    this.session = true;
    this.commandPrompt();
  }

  commandPrompt() {
    prompt(this.options.sessionPrompt,(cmd)=>{
      return this.parse(cmd);
    });
  }


  processCommand(command,values = {},checked = []) {

    if (_.isString(command)) {
      command = _.find(this.commands,{name: command});
    }

    let promise = Promise.resolve();

    if (command) {

      //prompt for any required values

      // validate values
      const commandOptions = command.options || [];
      commandOptions.forEach((opt)=>{

        let usedDefault;

        let value = values[opt.name];

        if (!opt.noPrompt && (this.session || (!value && opt.promptIfMissing)) && !_.includes(checked,opt.name)) {
          promise = promise.then(()=>{

            let promptIfMissing = opt.promptIfMissing;
       
            if (_.isFunction(promptIfMissing)) {
              promptIfMissing = promptIfMissing(values);
            }

            if (!promptIfMissing) { return Promise.resolve(); }


            return inquirerOptionsTransform(opt,values).then((optn)=>{
              if (optn.value != null) {
                value = optn.value;
                values[optn.name] = value;
                return true;
              }
              return new Promise((resolve)=>{
                inquirer.prompt([optn],(answers)=>{
                  value = answers[optn.name];
                  values[optn.name] = value;
                  checked = checked.concat([optn.name]);
                  resolve();
                });
              });
            });
          });
        }

        else if (!this.session && opt.default && (value == null)) {
          usedDefault = true;
          promise = promise.then(()=>utils.runPromise(opt.default,values)).then((def)=>{
            value = def;
            values[opt.name] = value;
            return value;
          });
        }

        promise = promise.then(()=>{

          let promise2 = Promise.resolve();

          if (opt.choices && value && (value !== opt.default)) {
            promise2 = promise2.then(()=>utils.runPromise(opt.choices,values)).then((choices)=>{
              if (choices) {
                choices = choices.map((choice)=> _.isObject(choice) ? choice.values : choice);
                const list = _.isArray(value) ? value : [value];
                if (!opt.choiceIsOpen) {
                  list.forEach((val)=>{
                    if (!_.includes(choices,val)) {
                      const err = new Error(`Value of '${opt.name}' should be one of :\n ${chalk.green("-")} '${choices.join(`'\n ${chalk.green('-')} '`)}'`);
                      err.name = "ValidationError";
                      err.command = command;
                      err.option = opt;
                      err.input = value;
                      err.isFriendly = true;
                      throw err;
                    }
                  });
                }
              }
            });
          }

          if (opt.validate) {
            promise2 = promise2.then(()=>utils.runPromise(opt.validate,value,values)).then((valid)=>{
              if (!valid) {
                const err = new Error(`${opt.name} is not valid`);
                err.name = "ValidationError";
                err.command = command;
                err.option = opt;
                err.input = value;
                throw err;
              }
            });
          }

          if (opt.transform && !usedDefault) {
            promise2 = promise2.then(()=>utils.runPromise(opt.transform,value,values)).then(function(result) {
              values[opt.name] = result;
            });
          }

          return promise2;
        });
      });



      promise = promise.then(()=>{
        if (command.callback) {
          return Promise.resolve(command.callback(values));
        }

        this.log.warn(`The command '${command.name}' has not yet been implemented`);
        return false;

      });

      promise.catch((e)=>{
        if (this.session && e.name === "ValidationError") {
          command = e.command;
          const option = e.option;
          return inquirerOptionsTransform(option,values).then((opt)=>{
            inquirer.prompt([opt],(answers)=>{
              this.processCommand(command,_.extend({},values,answers),checked);
            });
          });
        }

        return Promise.reject(e);

        // else {
        //   this.log.error(`${chalk.grey(e.name)}: `,e.message);
        // }

        //throw (e);
      });

      return promise;
    }


    return Promise.reject(FriendlyError("Command not found"));

  }



  parse(options) {
    options = options && (_.isArray(options) || spawnargs(options));
    this.nomnom.parse(options);
  }
}


module.exports = CLI;
