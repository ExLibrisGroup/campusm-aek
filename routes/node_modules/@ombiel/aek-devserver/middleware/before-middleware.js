const fs = require("fs-extra");
const path = require("path");
const express = require("express");
const yaml = require("js-yaml");
const _ = require("lodash");
const inspect = require("eyes").inspector();
const cookieParser = require("cookie-parser");

const log = require("@ombiel/aek-cli-support/logger");
const auth = require("@ombiel/aek-cli-support/auth");

const startupMiddleware = require("./startup-middleware");
const screenBuilderMiddleware = require("./screen-builder-middleware");
const screenMiddleware = require("./screen-middleware");

function initBeforeMiddleware(options) {
  const router = express.Router();
  // let token;

  let conf = {};
  const configPath = "./runserver.yaml";

  function reloadConfig() {
    return fs
    .readFile(configPath)
    .then(data => {
      return data;
    })
    .catch(() => {
      log.warn("runserver.yaml config not found");
    })
    .then(data => {
      if (data) {
        let newConf;
        try {
          newConf = yaml.load(data.toString());
        }
        catch (e) {
          log.error("Error parsing runserver.yaml");
          inspect(e);
        }
        if (newConf) {
          conf = newConf;
          log.info("new runserver.yaml config applied");
        }
        else {
          conf = {};
        }
      }
    });
  }

  return reloadConfig().then(() => {
    fs.watchFile(configPath, reloadConfig);

    // renew token every 5 mins
    setInterval(() => {
      auth.renew();
      // .then((obj)=>{
      //   token = obj.token;
      // });
    }, 5000 * 60);

    let targetProtocol = options.targetProtocol;
    if (targetProtocol) {
      const targetProtocolMatch = targetProtocol.match(/https?/);
      if (targetProtocolMatch && targetProtocolMatch[0]) {
        targetProtocol = targetProtocolMatch[0];
      }
      else {
        targetProtocol = null;
      }
    }
    if (!targetProtocol) {
      targetProtocol = "https";
    }
    const hostname = options.hostname;
    let targetPort = options.targetPort;
    if (targetPort != null) {
      const targetPortMatch = targetPort.toString().match(/\d+/);
      if (targetPortMatch && targetPortMatch[0]) {
        targetPort = parseInt(targetPortMatch[0], 10);
      }
      else {
        targetPort = null;
      }
    }

    const targetBaseURL = `${targetProtocol}://${hostname}${
      targetPort ? `:${targetPort}` : ""
    }`;

    options.targetBaseURL = targetBaseURL;
    options.targetProtocol = targetProtocol;

    if (_.isObject(conf.plugins)) {
      _.forEach(conf.plugins, (plugin, route) => {
        let requirePath = plugin;
        if (plugin.indexOf("-/") === 0) {
          requirePath = path.resolve("./", plugin.substr(2));
        }
        // exclude old buildtools plugins
        if (plugin.indexOf("@ombiel/aek-buildtools") > -1) {
          return;
        }
        router.use(route, require(requirePath));
      });
    }

    router.get("/", (req, res) => {
      res.redirect("/campusm");
    });

    router.use("/public", express.static("public", {}));

    router.use(cookieParser("popgoestheweasel123987456"));
    // router.use(expressSession({secret: 'whyinever34598277II!',resave: true,saveUninitialized: true}));

    // intercept appcache manifest to stop caching accross hostnames
    router.get("/campusm/*.appcache", (req, res) => {
      res.status(404);
      res.send("AppCache Disabled for DEV environment");
    });

    // assign current config to every request
    router.use((req, res, next) => {
      req.aekConfig = conf;
      next();
    });

    router.use((req, res, next) => {
      if (req.cookies.aekt_hostname !== hostname) {
        delete req.headers.cookie;
        _.forEach(req.cookies, (val, name) => {
          res.clearCookie(name);
        });
      }
      next();
    });

    router.use(startupMiddleware(options));

    router.use(screenBuilderMiddleware(options));

    router.use(screenMiddleware(options));

    return router;
  });
}

module.exports = initBeforeMiddleware;
