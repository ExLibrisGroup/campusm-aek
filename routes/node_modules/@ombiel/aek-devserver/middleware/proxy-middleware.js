const URL = require("url");
const express = require("express");
const _ = require("lodash");
const httpProxy = require("http-proxy");
const Cookie = require("cookie");

function proxyMiddleware(options) {
  const router = express.Router();
  const {userDetails,targetBaseURL,targetProtocol,hostname} = options;

  if (userDetails.apps === "all" || _.includes(_.map(userDetails.apps,"hostname"),options.hostname)) {

    const proxyOpts = {changeOrigin: true};

    // if user need to use a proxy for remote network
    if (options.useProxy) {
      const proxyURL = URL.parse(options.useProxy);
      const tunnel = require("../lib/tunnel");
      proxyOpts.agent = tunnel[proxyURL.protocol === "https" ? "httpsOverHttps" : "httpsOverHttp"]({
        // maxSockets: poolSize, // Defaults to 5
        rejectUnauthorized: !options.bypassSSLVerification,
        proxy: {
          host: proxyURL.hostname || "localhost",
          port: proxyURL.port || 8888,
          rejectUnauthorized: !options.bypassSSLVerification,
        },
      });
    }

    const proxy = httpProxy.createProxyServer(proxyOpts);

    proxy.on("error",(/*...args*/)=>{
      //  not sure what to do here - we need to supress errors that occur when changing apps and using the same hostname (ie localhost)
      //  but supressing these may have other side effects
      // console.log("ERROR",args)
    });


    // modify request that's proxied
    proxy.on('proxyReq', (proxyReq, req, /*res, options*/)=>{
      // if this request has been flagged for no compression, we remove the header in the proxied request
      // this is so we can easily modify the returned data


      if (req.removeQueryString) {
        proxyReq.path = proxyReq.path.split("?")[0];
      }
    });

    router.use((req,res)=>{
      // if the original request is not secure, we need to remove the secure flags on all the cookies
      const isSecure = (req.protocol === "https") || (req.headers['x-forwarded-proto'] === 'https');

      const parsedURL = URL.parse(req.url);

      res.oldSetHeader = res.setHeader;

      res.setHeader = function(name, value) {
        if (name.toLowerCase() === "set-cookie") {
          if (!_.isArray(value)) {
            value = [value];
          }
          if (!isSecure) {
            value = _.map(value,(cookie)=>{
              return cookie.replace("; secure","");
            });
          }
          if (!_.find(value,(c)=>c.indexOf("aekt_hostname") === 0)) {
            value = value.concat(Cookie.serialize("aekt_hostname",hostname,{maxAge: (1000 * 60 * 60 * 24 * 365),path: "/"}));
          }
        }

        res.oldSetHeader(name, value);
      };



      let screenPath = req.aekScreenPath;

      if (screenPath) {

        if (req.path.match(/^\/campusm\/sso\/required/i)) {
          screenPath = `/campusm/sso/required${screenPath}`;
        }
        else if (req.path.match(/^\/campusm\/sso/i)) {
          screenPath = `/campusm/sso${screenPath}`;
        }

        req.url = screenPath + (parsedURL.search || "");

        if (req.url.indexOf("?") > -1) {
          req.url += "&";
        }
        else {
          req.url += "?";
        }

        req.url += `_ombl_script_name=${encodeURIComponent(parsedURL.pathname)}`;
      }


      const proxyOptions = {
        changeOrigin: true,
        target: targetBaseURL,
        secure: targetProtocol === "https",
        headers: {},
      };

      if (req.preventCache) {
        proxyOptions.headers['cache-control'] = '';
        proxyOptions.headers['if-none-match'] = '';
      }

      if (req.preventCompression) {
        proxyOptions.headers['Accept-Encoding'] = '';
      }


      proxy.web(req,res,proxyOptions);


    });

  }

  return router;
}

module.exports = proxyMiddleware;
