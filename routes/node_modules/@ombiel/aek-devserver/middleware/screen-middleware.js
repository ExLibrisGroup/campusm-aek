const express = require("express");
const Path = require("path");
const fs = require("fs-extra");
const _ = require("lodash");
const nodeHtmlEncoder = require("node-html-encoder");
const { getDC } = require("@ombiel/aek-cli-support/utils");
const log = require("@ombiel/aek-cli-support/logger");
const { getStoredCreds } = require("@ombiel/aek-cli-support/auth");
const { getDevScreens } = require("../modules/screen");
const request = require("../lib/request-promise");

const htmlEncoder = new nodeHtmlEncoder.Encoder("entity");

function screenMiddleware(options = {}) {
  const screenDir = _.get(options, "screenDir", "./screens");
  const { userDetails, targetBaseURL } = options;
  const { username } = userDetails;
  const dc = getDC(username);

  const router = express.Router();

  function getDevScreensForRequest(req) {
    return getDevScreens(screenDir, req.screens);
  }

  const screenCache = {};
  const previews = {};

  router.use((req, res, next) => {
    if (req.url.match(/^\/c\//)) {
      req.url = `/aek${req.url}`;
    }
    next();
  });

  router.use((req, res, next) => {
    const screenMatch = req.path.match(
      /\/aek(\/[a-zA-Z0-9\-_]+\/[a-zA-Z0-9\-_]+)?\/c\/([a-zA-Z0-9\-_]+)/
    );
    let screenName = screenMatch && screenMatch[2];
    if (!screenName) {
      next();
      return;
    }

    let pkgData;
    let devScreen;
    getStoredCreds().then(({ token }) => {
      getDevScreensForRequest(req, res)
      .then(result => {
        const screens = result.screens;
        pkgData = result.pkgData;
        devScreen = screens[screenName];
        if (devScreen) {
          screenName = devScreen.name;
          if (devScreen.content) {
            return devScreen.content;
          }
        }

        const screenPath = Path.resolve(screenDir, `${screenName}.twig`);

        if (fs.existsSync(screenPath)) {
          return fs.readFile(screenPath).then(data => {
            return data.toString();
          });
        }

        throw Error("No Screen found");
      })
      .then(content => {
        if (content) {
          const cache = screenCache[screenName] || {};
          if (content === cache.source) {
            req.aekScreenPath = cache.url;
          }
          else {
            const source = content
            .replace(
              "[[__package_data__]]",
              htmlEncoder.htmlEncode(
                JSON.stringify(
                  _.extend({}, pkgData, { screen: screenName })
                )
              )
            )
            .replace(/\[\[__public_assets__\]\]/g, "/public");

            if (devScreen && devScreen.offline) {
              res.set("content-type", "text/html");
              res.send(source);
              return true;
            }

            return request
            .post(
              `${options.appManagerBase || dc.appManagerBase}/aek/tools/save_preview`,
              {
                strictSSL: !options.bypassSSLVerification,
                form: {
                  source: source,
                  username: dc.username,
                  token: token,
                  hostname: options.hostname
                }
              }
            )
            .then(([, amBody]) => {
              const parsedResponse = JSON.parse(amBody);
              cache.url = parsedResponse.url.replace(targetBaseURL, "");
              cache.source = source;
              screenCache[screenName] = cache;
              previews[cache.url] = screenName;

              req.aekScreenPath = cache.url;
            })
            .catch(err => {
              res.send(500, {
                error: "Unable to retreive preview screen from server"
              });
              log.error(err, err.body);
              return true;
            });
          }
        }
        return false;
      })
      .catch(err => {
        log.error("Error getting screens", err);
        log.error(err);
      })
      .then(handled => {
        if (!handled) {
          next();
        }
      });
    });
  });

  return router;
}

module.exports = screenMiddleware;
