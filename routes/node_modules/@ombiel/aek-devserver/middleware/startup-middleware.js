const express = require("express");
const _ = require("lodash");

const IDs = {
  menu: {
    attr: "code",
    clone: "desc",
  },
};

function startupMiddleware(/*options*/) {

  const router = express.Router();

  // intercept startup requests to inject test data if `homepage` section present in conf
  router.use("/campusm/startupmep/:profileID",(req,res,next)=>{
    const conf = req.aekConfig;
    if (conf.homepage) {

      // remove query string and preventCache so we always get fresh data
      // set a flag here and remove at proxy
      // todo: improve and optimise this by maintaining local cache
      req.removeQueryString = true;
      req.preventCache = true;

      // in order to modify the returned data, we need to switch any compression off - we flag it here and apply it later in the proxy request
      req.preventCompression = true;


      // hijack writeHead to prevent content-length header
      const setHeader = res.setHeader.bind(res);
      res.setHeader = function(name,value,...args) {
        if (name.toLowerCase() !== "content-length") {
          setHeader(name,value,...args);
        }
      };

      // now we hijack the responses `write` method in order to buffer the content and modify it
      const write = res.write.bind(res);
      res.write = function(body) {
        if (!res.body) { res.body = ""; }
        res.body += body.toString();
      };

      const end = res.end.bind(res);
      res.end = function() {
        const startup = JSON.parse(res.body);

        const homepageConf = conf.homepage;

        const menuItems = _.get(homepageConf,"menu.replace",[]).concat(_.get(homepageConf,"menu.append",[]));

        menuItems.forEach((menuItem)=>{

          if (menuItem.screenName) {
            if (!menuItem.code) { menuItem.code = menuItem.screenName; }
            if (!menuItem.devPath) { menuItem.devPath = `/aek/c/${menuItem.screenName}`; }
          }

          if (menuItem.devPath) {
            menuItem.menuRefCode = menuItem.code;
            menuItem.aekCode = "AEK";
            if (!homepageConf.webUIComponents) { homepageConf.webUIComponents = {}; }
            if (!homepageConf.webUIComponents.append) { homepageConf.webUIComponents.append = []; }
            const webUIComponents = homepageConf.webUIComponents.append;
            webUIComponents.push({menuRefCode: menuItem.code,path: menuItem.devPath});
            if (!homepageConf.aekToolbars) { homepageConf.aekToolbars = {}; }
            if (!homepageConf.aekToolbars.append) { homepageConf.aekToolbars.append = []; }
            const aekToolbars = homepageConf.aekToolbars.append;
            aekToolbars.push({code: menuItem.code,items: [{webUIMDCode: menuItem.code}]});
          }
        });




        // MODIFY STARTUP HERE
        _.forEach(homepageConf,(value,key)=>{
          let target = startup;
          if (_.includes(["stylesheets","scripts"],key)) {
            if (!startup.web2Data) { startup.web2Data = {}; }
            target = startup.web2Data;
          }
          if (value.merge) {
            target[key] = _.merge({},target[key],value.merge);
          }
          if (value.replace) {
            target[key] = value.replace;
          }
          if (value.append) {
            target[key] = target[key] || [];
            target[key] = target[key].concat(value.append);
          }
          if (IDs[key]) {
            _.forEach(target[key],(item)=>{
              if (!item[IDs[key].attr]) {
                item[IDs[key].attr] = (IDs[key].clone && item[IDs[key].clone]) || _.uniqueId();
              }
            });
          }
        });


        write(JSON.stringify(startup));
        end();
      };
    }

    next();
  });

  return router;
}

module.exports = startupMiddleware;
