# SimpleStore

A simple state container offering some flux-like features with less boilerplate

- [Basic Usage](#basic)
- [Constructor](#constructor)
- [Methods](#methods)
- [Dispatching Actions](#dispatching)
- [Custom Stores](#custom-stores)
- [Asynchronous Dispatchers](#async-dispatch)
- [Contexts](#contexts)
- [Reacting to Changes](#changes)
- [Using with React](#react)
- [Plugins](#plugins)
- [Immutable State](#immutable)
- [Built-in Events](#events)
- [Custom Events](#custom-events)
- [Plugin Development](#plugin-dev)

<a name="basic"></a>
## Basic Usage

```javascript

import {SimpleStore} from "@ombiel/aek-lib/simple-store";

const store = new SimpleStore({
  initialState:{
    foo:{
      bar:["zero","one","two"]
    }
  }
});

store.get("foo.bar.1");
// returns "one"

store.set("foo.bar.0",{isZero:"Yes it is",v:"hello"});
store.get("foo.bar.0.isZero");
// returns "Yes it is"

store.state.foo.bar[0].v;
// returns "hello"

```

------

<a name="constructor"></a>
## Constructor

### `new SimpleStore(options:Object)`

| options            | type                              | default | description                                       |
|:-------------------|:----------------------------------|:--------|:--------------------------------------------------|
| **`initialState`** | `Object`                          | `{}`    | An object to define the stores initial state tree |
| **`plugins`**      | `Array<(store:SimpleStore):void>` | `[]`    | An array of plugins to apply to the store         |

--------------
<a name="methods"></a>
## Methods

### `asMutable(obj)`

Convert an immutable object from the state tree to a mutable equivalent. If `obj` is not an immutable, simply returns `obj` unchanged.

_ See [Immutable State](#immutable) below _

----

### `dispatch(description:Object)`

| Option        | Type                  | Description                                                                          |
|:--------------|:----------------------|:-------------------------------------------------------------------------------------|
| **`name`**    | `string`              | Name of action (optional <sup>1</sup>)                                               |
| **`group`**   | `string`              | Name of action (optional <sup>1</sup>)                                               |
| **`replace`** | `mixed` or `Function` | Modifier to replace data at specified path (optional <sup>2</sup>)                   |
| **`extend`**  | `mixed` or `Function` | Modifier to extend data at specified path (optional <sup>2</sup>)                    |
| **`path`**    | `string` or `Array`   | Path for state tree to modify (required)                                             |
| **`error`**   | `Error`               | Use when dispatching an error (optional)                                             |
| **`log`**     | `Array`               | Provide additional data to log in the console when using the loggerPlugin (optional) |
| **`payload`** | `mixed`               | Payload specifies the parameters that are used in the action (optional)              |

<small><sup>1</sup> _A `name` or `group` must be provided_</small>  
<small><sup>2</sup> _At least one modifier (`extend` or `replace`) must be provided_</small>    

_ See [Dispatching Actions](#dispatching) below for more details_

---------

### `emit(eventName:string, ...args)`

Emits an event that can be listened to with `store.on(eventName)`. Additional args are sent to any callbacks registered to this event.

_ See [Custom Events](#custom-events) below for more info _

-------

### `get(path, defaultValue = null)`

Gets the value from the state tree defined by path. If the property is undefined, returns `defaultValue`

`path` can be a `string` eg `"foo.bar.1"` or an `Array` eg `["foo","bar",1]`  

------

### `off(eventName:?string, fn:?Function)`

Removes specified listeners

_ See [Events](#events) below for more info _

-----

### `on(eventName:string, fn:Function)`

Adds a listener that triggers `fn` when an event with `eventName` is emitted

_ See [Events](#events) below for more info _

-----

### `set(path, value)`

Sets the state tree at the given path to a new value

`path` can be a `string` eg `"foo.bar.1"` or an `Array` eg `["foo","bar",1]`

----------
<a name="dispatching"></a>
## Dispatching Actions

Beyond simple `get`/`set` commands, SimpleStore allows us to organise and structure our store by defining identifiable "Actions" that work on specific parts of the state tree.

This allows the developer to use Flux-like patterns but with more flexibility and less boilerplate code.

In SimpleStore, we can define and dispatch an "Action" in a single call.

`store.dispatch(description)`

Given the following state tree...

```javascript

{
  foo:{
    bar:{
      counter:0
    }
  }
}

```

We can define and dispatch an action to set our counter to 10:

```javascript
store.dispatch({
  name:"SET_COUNTER",
  path:"foo.bar.counter"
  replace:10
});
```

We could also define and dispatch an action to increment our counter:

```javascript
store.dispatch({
  name:"INCREMENT_COUNTER",
  path:"foo.bar.counter",
  replace:(counter)=>counter + 1
});
```

In the above examples, we are using the `replace` modifier. This can be a static value (as with the first example) or a function that works on the current value (as with the latter)

Typically, we want to make this sort of logic re-usable so we can simply wrap the code in a function and this can be thought of as a "Dispatcher"

```javascript
let incrementCounter = ()=> {
  store.dispatch({
    name:"INCREMENT_COUNTER",
    path:"foo.bar.counter",
    replace:(counter)=>counter + 1
  });
};
```

Now, anytime we want to increment our counter, we simply call `incrementCounter()`

We can also introduce parameters into our dispatchers

```javascript
let incrementCounterBy = (increment)=> {
  store.dispatch({
    name:"INCREMENT_COUNTER_BY",
    path:"foo.bar.counter",
    replace:(counter)=>counter + increment
  });
}
```

It is good practice to ensure that our "modifiers" are pure functions and so we should declare our parameters inside the dispatch. We do this inside a `payload` which is passed on to the modifier. The above can be re-writen:

```javascript
let incrementCounterBy = (increment)=> {
  store.dispatch({
    name:"INCREMENT_COUNTER_BY",
    path:"foo.bar.counter",
    payload:increment,
    replace:(counter,increment)=>counter + increment
  });
}
```

For convenience, an alternative modifier `extend` is also available instead of `replace`, this allows us to perform a common task of modifying properties in an existing object on the state tree.

Instead of...

```javascript
store.dispatch({
  name:"SET_ANOTHER",
  path:"foo.bar",
  payload:someValue,
  replace:(bar,payload)=>{
    bar.another = payload;
    return bar;
  }
});
```

We can write...

```javascript
store.dispatch({
  name:"SET_ANOTHER",
  path:"foo.bar",
  payload:someValue,
  extend:(bar,payload)=>{another:payload}
});
```


-------------------
<a name="custom-stores"></a>
## Custom Stores

In order to organise our dispatchers, SimpleStore has been designed with extendibility in mind. As such, we can create our own custom store and define dispatchers as methods of our custom store.

Typically, we would define our store in its own module that can be imported wherever its needed. Using our incrementCounter dispatcher, our custom store module would look something like this

```javascript

// modules/store.es6.js

import {SimpleStore} from "@ombiel/aek-lib/simple-store";

class Store extends SimpleStore {

  incrementCounterBy(increment) {
    this.dispatch({
      name:"INCREMENT_COUNTER_BY",
      path:"foo.bar.counter",
      payload:increment,
      replace:(counter,increment)=>counter + increment
    });
  }

  resetCounter() {
    this.dispatch({
      name:"RESET_COUNTER",
      path:"foo.bar.counter",
      replace:0
    });
  }

  setCounter(value) {
    this.dispatch({
      name:"SET_COUNTER",
      path:"foo.bar.counter",
      payload:value,
      replace:value
    });
  }

}

module.exports = new Store();

```

We can also define a constructor for our store to provide initialState and any other initialisation code.

```javascript

// modules/store.es6.js

import {SimpleStore} from "@ombiel/aek-lib/simple-store";

class Store extends SimpleStore {

  constructor() {
    super({
      initialState:{
        foo:{
          bar:{
            counter:0
          }
        }
      }
    });
  }

  incrementCounterBy(increment) {
    this.dispatch({
      name:"INCREMENT_COUNTER_BY",
      path:"foo.bar.counter",
      payload:increment,
      replace:(counter,increment)=>counter + increment
    });
  }

  ...

}

module.exports = new Store();

```

Then in another module we'd use our store like this

```javascript

const store = require("./modules/store");

store.incrementCounterBy(2);
store.incrementCounterBy(3);

console.log(store.state.foo.bar.counter) // returns 5

```

----------------
<a name="async-dispatch"></a>
## Asynchronous Dispatchers

Dispatchers can dispatch multiple actions at specific points in an async process. A typical API request for example might look like this.

```javascript

class Store extends SimpleStore {

  fetchInfo() {
    this.dispatch({
      group:"INFO",
      name:"fetching",
      path:"info",
      replace:{loading:true}
    })

    request.get("https://my.api.com/info")
    .then((res)=>{
      this.dispatch({
        group:"INFO",
        name:"fetched",
        path:"info",
        replace:{data:res.body}
      });
    })
    .catch((err)=>{
      this.dispatch({
        group:"INFO",
        name:"error",
        path:"info",
        error:err,
        replace:{error:err}
      });
    });
  }
}

module.exports = new Store();

```

Note in the above, that we have used the `group` property in the dispatch descriptions. This helps us group related actions together.

----------
<a name="contexts"></a>
## Contexts

Note in the above example how we are repeating properties like `group` and `path` for each dispatch. A Context provides a `dispatch` method with some base options predefined, this can help us organising batches of related dispatches, particularly when defining asynchronous processes. Using a context, we can rewrite the previous example:

```javascript

class Store extends SimpleStore {

  fetchInfo() {

    const ctx = this.context({group:"INFO",path:"info"});

    ctx.dispatch({
      name:"fetching",
      replace:{loading:true}
    })

    request.get("https://my.api.com/info")
    .then((res)=>{
      ctx.dispatch({
        name:"fetched",
        replace:{data:res.body}
      });
    })
    .catch((err)=>{
      ctx.dispatch({
        name:"error",
        error:err,
        replace:{error:err}
      });
    });
  }
}

module.exports = new Store();

```

-----------
<a name="changes"></a>
## Reacting to Changes

In order to make use of our store, we typically need to respond to changes in the store's state. SimpleStore emits a "change" event whenever the state is modified in any way.

We can use the `on` method to listen and react to those events

```javascript

store.on("change",()=>{ /* doSomething */ });

```

Note that for every modification, the state is re-evaluated and compared to its previous value. This is a deep comparison of the entire state tree comparing values, not references. The "change" event is only emitted if the new state is different from the previous. If a modification is made but the state does not change, a "nochange" event is emitted.

```javascript

  store.set("foo",[1,2,3]);
  // emits "change"

  store.set("foo",[1,2,3,4]);
  // emits "change"

  store.set("foo",[1,2,3,4]);
  // emits "nochange"

```

-------------------
<a name="react"></a>
## Use with React

In React, we can use a change listener to force a re-render. We typically only need to do this once at the top/root component in our app.

```javascript

class Screen extends React.Component{
  componentDidMount() {
    store.on("change",()=>{
      this.forceUpdate();
    });
  }

  ...

};

```

We can use the above `fetchInfo` dispatcher in a simple screen that renders a loading spinner while the data is being fetched, when the API call is complete, the data will be used to populate a table. If an error occurs, the message will be sent to the user.

``` javascript

class Screen extends React.Component{

  componentDidMount() {
    store.on("change",()=>{
      this.forceUpdate();
    });
    store.fetchInfo();
  },

  render() {

    var info = store.state.info || {};
    var {loading,data,error} = info;
    var content;

    if(data) {
      content = <Table data={data} />;
    }
    else if (error) {
      content = <ErrorMessage heading="Oops!">{error}</ErrorMessage>;
    }

    return (
      <Container>
        <Page>
          <Segment loading={loading}>
            {content}
          </Segment>
        </Page>
      </Container>
    );

  }

};


```


-------------------
<a name="plugins"></a>
## Plugins

Plugins can be added to our stores to provide additional features.

Plugins are contained in their own modules that export a factory function. This allows them to be instantiated with configuration options. We declare plugins in our store's constructor.

```javascript

import {SimpleStore,loggerPlugin,localStoragePlugin,windowSizePlugin} from "@ombiel/aek-lib/simple-store";

class Store extends SimpleStore {

  constructor() {
    super({
      initialState:{},
      plugins:[
        loggerPlugin(),
        localStoragePlugin("myStorageKey"),
        windowSizePlugin()
      ]
    })
  }

}
```

<a name="logger"></a>
### Logger Plugin

The Logger Plugin logs events that are emitted in the browser console. This can be very useful for debugging by providing a chronological record of all
actions and state changes.

This plugin also adds a `logger` property to the store, so you can use it to debug additional information

```javascript

store.logger.log("MY_LOG",someData);
store.logger.info("MY_INFO",someInfo);
store.logger.warning("MY_WARNING",someWarning);
store.logger.error("MY_ERROR",someError);

```

This offers a few advantages over the standard `window.console` by providing some color coding and automatic removal from production builds.

Open up the browser console and see how it responds to state changes in the example below:

<script type="text/aek-example" data-component="Example">

  import {Button,ButtonGroup,Segment} from "@ombiel/aek-lib";
  import {SimpleStore,localStoragePlugin,loggerPlugin} from "@ombiel/aek-lib/simple-store";

  class Store extends SimpleStore {

    constructor() {
      super({
        initialState:{},      
        plugins:[
          loggerPlugin()
        ]
      });
    }

    incrementCounterBy(increment) {
      store.dispatch({
        name:"INCREMENT_COUNTER_BY",
        path:"foo.bar.counter",
        payload:increment,
        replace:(counter,increment)=>(counter || 0) + increment
      });
    }

    resetCounter() {
      store.dispatch({
        name:"RESET_COUNTER",
        path:"foo.bar.counter",
        replace:0
      });
    }

  }


  var store;

  class Example extends React.Component{

    startStore = ()=> {
      store = new Store();
      store.on("change",()=>{
        this.forceUpdate();
      });
    }

    toggleStore = ()=>  {
      if(store) {
        store = null;
      }
      else {
        this.startStore();
      }
      this.forceUpdate();
    }

    handleClick = (ev)=>  {
      ev.preventDefault();
      if(!store) { this.startStore(); }
    }

    incrementClick = (ev)=>  {
      this.handleClick(ev);
      store.incrementCounterBy(1);
    }

    resetClick = (ev)=>  {
      this.handleClick(ev);
      store.resetCounter();
    }

    render() {

      var content;
      var active = !!store;

      if(active) {
        content = <pre>{JSON.stringify(store.state,null,2)}</pre>
      }

      return (
        <div>
          <ButtonGroup divided>
            <Button onClick={this.toggleStore} variation={active ? "negative" : "positive"}>
              {active ? "Stop" : "Start"}
            </Button>
            <Button onClick={this.incrementClick}>Increment</Button>
            <Button onClick={this.resetClick}>Reset</Button>
          </ButtonGroup>
          <Segment style={{height:200}} placeholder="Click Start to Try Me">{content}</Segment>
        </div>
      )
    }

  };

</script>

-------

<a name="localstorage"></a>
### LocalStorage Plugin

With the LocalStorage Plugin, your state tree will be automatically persisted to localStorage each time it changes. The state tree will be retrieved from localStorage every time it reloads.

This plugin must be instantiated with a storage key. This key should be unique and specific to the store in use. Generally it is good practice to use explicit naming.

```javascript
localStoragePlugin("mycu-aek-library-search-v1")
```

You can also optionally provide a serializer and deserializer. This can be useful if you need to transform your state data in any way before storing or retrieving.

```javascript
localStoragePlugin("mycu-aek-library-search-v1",{
  serialize:(state)=>{
    return JSON.stringfy(_.omit(store.asMutable(state),"tmp"));
  },
  deserialize:(str)=>{
    return _.extend(JSON.parse(str),{tmp:{}});
  }
})
```

If omitted, the default serializer/deserializer will omit any properties that are prefixed with `"$$$"` allowing you to safely define temporary properties (such as loading state) that are only relevant to the current lifespan of the page.

```javascript
store.set("foo",{$$$loading:true});
```


<a name="windowsize"></a>
### WindowSize Plugin

The WindowSize plugin monitors changes in the browsers window size and provides updated data `width` and `height` properties each time this changes. This allows you to design responsive components in your code that respond immediately to changes in the window size or device orientation and modify the component layout to accomodate the new area.

The advantage of having this in a central state model is that you only need a single event listener and a single change event will re-render all your components in a single go which avoids expensive DOM layout thrashing.

By default, the plugin will apply the width and height to a property called `"$$$windowSize"` in the store's state tree but this can be modified using the `propertyName` argument in the plugins initializer.

```javascript

windowSizePlugin()
// results in {$$$windowSize:{width:800,height:600}}

windowSizePlugin("windowDimensions")
// results in {windowDimensions:{width:800,height:600}}

```

Try resizing the window and watch how the state tree changes in the example below

<script type="text/aek-example" data-component="Example">

  import {SimpleStore,windowSizePlugin} from "@ombiel/aek-lib/simple-store";
  import {Segment} from "@ombiel/aek-lib";

  const store = new SimpleStore({
    initialState:{
      foo:"bar"
    },
    plugins:[
      windowSizePlugin()
    ]
  });

  class Example extends React.Component{

    componentDidMount() {
      store.on("change",()=>{
        this.forceUpdate();
      });

    }

    render() {

      return (
        <Segment style={{height:200}}><pre>{JSON.stringify(store.state,null,2)}</pre></Segment>
      )
    }

  };

</script>

-------------------
<a name="immutable"></a>
## Immutable State

The state tree in SimpleStore is immutable. This prevents inadvertent side effects that may occur by modifying state directly. SimpleStore uses the [seamless-immutable library](https://github.com/rtfeldman/seamless-immutable) to provide data structures that behave like normal Objects and Arrays but are immutable. Any attempts to modify the state directly will throw an error.

```javascript

store.set("foo.bar",["zero","one","two","three"]);

store.state.foo.bar[1];
// returns "one"

store.state.foo.bar.push("four");
// throws ImmutableError

```

Core Array and Object methods such as `Array.push()` that mutate the target object are not permitted. Methods that work on the original object but return a new one (like `Array.concat()` will work, but the returned object will be an immutable as well.

_ Due to the expense of freezing the state tree, these errors are only thrown in development mode. For performance, this behaviour is switched off in production builds _

```javascript

let newBar = store.state.foo.bar.concat(["four"]);
// returns Immutable(["zero","one","two","three","four"])

newBar.push("five");
// throws ImmutableError

```

Each SimpleStore instance provides an `asMutable()` method which will return a new mutable version of the provided object.

```javascript

let mutableBar = store.asMutable(store.state.foo.bar);

mutableBar.push("five");
// we now have a new array called mutableBar = ["one","two","three","four","five"]
// however our state remains unchanged

// we could apply this new array to the state using store.set
store.set("foo.bar",mutableBar)

store.state.foo.bar
// returns Immutable(["one","two","three","four","five"])

```

Note that `store.get()` also returns the immutable state

```javascript

store.get("foo.bar")
// returns Immutable(["one","two","three","four","five"])

```

However, dispatchers provide a mutable clone from the state tree at the given path

```javascript

store.dispatch({name:"MY_ACTION",path:"foo.bar",replace:(data)=>{

  data.push("six");
  data = ["one","two","three","four","five","six"]

  return data;

}});

```

-------------------
<a name="events"></a>
## Built-in Events

We have seen above how you can use the "change" event to react to changes in state. There are a few additional events that are triggered at other points in the store's lifecycle.

### `on("init",(state)=>{})`

Triggered once the store has been initialised and all plugins loaded.

### `on("change",(state,prevState)=>{})`

Triggered when state is modified in any way

### `on("nochange",(state)=>{})`

Triggered when a `dispatch` or a `set` results in no change to the state tree.

### `on("dispatch",(description)=>{})`

Triggered when an action is dispatched

### `on("set",(path,value)=>{})`

Triggered when `store.set(path,value)` is called


--------------------------
<a name="custom-events"></a>
## Custom Events

You can also emit your own custom events

```javascript

  const store = new SimpleStore();

  let sum = 0;

  const cb = (first,second,third)=>{
    sum = sum + first + second + third
  }

  // emit event, nothing listening
  store.emit("myEvent",1,2,3);

  // sum = 0

  // add a listener to trigger cb
  store.on("myEvent",cb);

  // emit another event
  store.emit("myEvent",1,2,3);

  // sum = 6

  // switch off anything listening to "myEvent" that's bound to the cb function
  store.off("myEvent",cb);

  // sum = 6

  // emit an event again, this time nothing is listening
  store.emit("myEvent",1,2,3);

  // sum = 6

```

Create a listener using `store.on()`

```javascript

const doSomething = (arg1,arg2)=> { /* doSomething here */ };
const doSomethingElse = (arg1,arg2)=> { /* doSomething here */ };

// doSomething every time the event "myAction" is emitted
store.on("myEvent",doSomething);

// doSomethingElse every time the event "myAction" is emitted
store.on("myEvent",doSomethingElse);

```

Now you can emit events

```javascript

store.emit("myEvent","one","two");
// will trigger doSomething("one","two") and doSomethingElse("one","two")

store.emit("myEvent","three","four");
// will trigger doSomething("three","four") and doSomethingElse("three","four")

```

If we need to remove listeners we can use `store.off()`

```javascript

store.off("myEvent",doSomething)
// stops any "myEvent" listeners bound to the doSomething function (doSomethingElse will still be triggered)

store.off("myEvent")
// stops all "myEvent" listeners

```

-----------------------
<a name="plugin-dev"></a>
## Plugin Development

Plugins are modules that export a factory function. The factory function should return a function that works on the store. It would generally look something like this:


```javascript

const myPlugin = function(opts = {}) {

  /* work on opts here, often extending some defaults */

  let defaults = {
    message:"STATE HAS CHANGED"
  }

  opts = _.extend(defaults,opts);

  return (store)=> {

    /* you may need some early initialisation code here */

    /* but most the work will be done after the init event */
    store.on("init",()=>{

      /* usually we listen for additional events at this point that determine the plugins behaviour */

      store.on("change",(state)=>{
        console.log(opts.message,store.asMutable(state));
      });

    });

  }

}

module.exports = myPlugin;

```
