import {extend} from "lodash";
import clientTools from "../client-tools";
import {EventEmitter,normaliseError} from "../../index";





// in order to manage and handle oauth requests globally, we'll maintain a single promise
// at the topmost level of the app to prevent us repeating the same flow for simultaneous requests
const globalPromiseKey = "__CM_AEK_oAuthPromise";

// resets global promise by swallowing previous errors
// also used to generate the initial promise if it does not already exist
function resetGlobalPromise() {

  const globalPromise = window.top[globalPromiseKey] || Promise.resolve();

  window.top[globalPromiseKey] = globalPromise
  .catch(()=>{});

  return window.top[globalPromiseKey];

}

// returns the current global promise to chain/queue further token requests
// this will generally be the last request in the queue
function getGlobalPromise() {
  return window.top[globalPromiseKey] || resetGlobalPromise();
}

// reset the globalPromise
function setGlobalPromise(promise) {
  window.top[globalPromiseKey] = promise;
  return promise;
}




export function getToken(opts = {}) {

  // ensure global oAuth promise exists to throttle token requests
  // if allowrenew, we'll reset the promise as this is a different flow and may have a different result
  var initPromise = opts.allowrenew ? resetGlobalPromise() : getGlobalPromise();

  var returnPromise = initPromise
  .then(()=>{
    return new Promise((resolve,reject)=>{

      var events = new EventEmitter();

      events.on("success",function(tokenDetails) {
        resolve(tokenDetails);
      });

      events.on("error",function(message,details) {
        const error = normaliseError(message);
        if (details) {
          error.details = details;
        }
        reject(error);
      });

      events.on("success error",function() {
        events.off();
      });

      opts = extend({},opts,{cb: events.emit.bind(events)});

      return clientTools.invoke("oAuthToken",opts);

    });
  });

  // if allowrenew, we'll catch any errors at the global level
  // as the behaviour can return different results
  // in this way we only batch the norenewal requests
  var newGlobalPromise = opts.allowrenew ? returnPromise.catch(()=>{}) : returnPromise;

  setGlobalPromise(newGlobalPromise);

  newGlobalPromise
  .catch(()=>{})
  .then(()=>{
    // if the global promise is unchanged,
    // we can assume the queue has completed and reset for any future requests
    if (getGlobalPromise() === newGlobalPromise) {
      resetGlobalPromise();
    }
  });

  return returnPromise;

}
