import {
  find,once,forEach,debounce,remove,extend,isString,isNumber,isNaN,
} from "lodash";
import React from "react";
import ReactDOM from "react-dom";
import PropTypes from "../utils/prop-types-extra";

import mergeProps from "../utils/merge-props";
import pickHtmlProps from "../utils/pick-html-props";
import Panel from "./panel";

import {outerHeight,outerWidth} from "../../utils";


let flexWarning = function() {
  console.warn("AEK `flex` property has been deprecated, please use `data-flex` instead. Usage is the same only the name has changed for compatibility"); // eslint-disable-line no-console
};

flexWarning = once(flexWarning);


const layoutElements = [];

export function updateLayout() {
  forEach(layoutElements,function(element) {
    element.updateLayout();
  });
}

const debounceLayout = debounce(updateLayout,0);

function addLayoutElement(element) {
  layoutElements.push(element);
  debounceLayout();
}

function removeLayoutElement(element) {
  remove(layoutElements,function(el) {
    return element === el;
  });
  debounceLayout();
}

window.addEventListener("resize",updateLayout);

function getFlex(child) {
  var {flex,size} = child.props;
  if (flex != null) { flexWarning(); }
  if (flex == null) { flex = child.props["data-flex"]; }
  if (flex == null && size == null) { flex = 1; }

  if (flex === 0 && !child.key) {
    console.warn("layout children with flex==0 must have a defined key"); // eslint-disable-line no-console
    flex = 1;
  }

  return flex;
}

class Layout extends React.Component {

  constructor() {
    super();
    this.state = {measured: {}};
  }


  componentWillMount() {
    addLayoutElement(this);
    this.updateLayout();
  }

  componentDidMount() {
    this._isMounted = true;
    this.measure();
  }

  componentDidUpdate() {
    this.measure();
  }

  componentWillUnmount() {
    removeLayoutElement(this);
  }

  getWidth = ()=>{
    return this.getDimension("width");
  }

  getHeight = ()=>{
    return this.getDimension("height");
  }

  getDimension = (dimension)=>{
    let v = parseInt(this.props[dimension],10);
    if (isNaN(v)) {
      v = parseInt(this.state[dimension],10);
    }
    if (isNaN(v)) {
      return null;
    }

    return v;

  }



  updateLayout = (retry)=>{

    const state = {
      lastMeasured: this.state.measured || {}, //eslint-disable-line react/destructuring-assignment
      measured: {}
    };

    if (this.isMounted()) {
      var el;
      try {
        el = ReactDOM.findDOMNode(this); //eslint-disable-line react/no-find-dom-node
      }
      catch (e) {} // eslint-disable-line no-empty

      if (el) {
        if (this.props.width == null) {
          state.width = el.clientWidth;
        }
        if (this.props.height == null) {
          state.height = el.clientHeight;
        }
      }
    }
    try {
      this.setState(state);
    }
    catch (e) {} // eslint-disable-line no-empty


    // sometimes container isn't quite ready to measure - if height is zero, try again after a short delay
    if (state.height === 0 && !retry) {
      setTimeout(function() {
        this.updateLayout(true);
      }.bind(this),100);
    }

  }

  measure = ()=>{
    let measured;

    React.Children.forEach(this.props.children,((child)=>{

      if (!child) { return; }

      const flex = getFlex(child);

      if ((!child.props.size && child.props.size !== 0) && flex === 0) {

        let childMeasured;

        const domNode = this.findChildNode(child.key);

        // measurement can fail in Firefox if modal iframe is display:none - https://bugzilla.mozilla.org/show_bug.cgi?id=548397
        // in these scenarios, the measurement is very unlikely to have changed so we can just allow it to fail
        try {
          if (this.props.dimension === "height") {
            childMeasured = outerHeight(domNode);
          }
          else {
            childMeasured = outerWidth(domNode);
          }

          if (childMeasured !== this.state.measured[child.key]) {
            measured = measured || {};
            measured[child.key] = childMeasured;
          }
        }
        catch (e) {} //eslint-disable-line no-empty


        // if measurement is zero, this is probably because the is a layout
        // component and/or only has absolute positioned elements
        // so lets iterate over its children to get a measurement
        // if(measured[child.key]==0) {

        //   var max = 0
        //   _.each(domNode.children,function(subNode) {

        //     var val = parseFloat(window.getComputedStyle(subNode)[this.props.dimension]);
        //     if(val && val>max) {
        //       max = val
        //     }
        //   }.bind(this))
        //   measured[child.key] = max
        // }

      }
    }));
    if (measured) {
      measured = extend({},this.state.measured,measured);
      this.setState({measured: measured});
    }
  }

  isMounted() {
    return !!this.isMounted;
  }

  findChildNode(key) {

    if (!this.childNodes) {
      this.childNodes = {};
    }

    if (this.childNodes[key]) {
      return this.childNodes[key];
    }

    var el = this.el;

    if (!this.el) {
      try {
        el = ReactDOM.findDOMNode(this); //eslint-disable-line react/no-find-dom-node
        this.el = el;
      }
      catch (e) {} // eslint-disable-line no-empty
    }

    this.childNodes[key] = find(el.children,(el1)=>{
      return el1.getAttribute("data-cm-layout-key") === key;
    });

    return this.childNodes[key];

  }

  // updateStateFromProps:function(nextProps) {
  //   var state = {}

  //   _.each(["height","width","top","left"],function(key) {
  //     if(nextProps[key] != null) {
  //       state[key] = nextProps[key]
  //     }
  //   }.bind(this))

  //   this.setState(state)
  // },

  // componentWillReceiveProps:function(nextProps) {

  //   this.updateStateFromProps(nextProps)

  // },



  render() {

    const dimension = this.props.dimension || "height";
    // const posDimension = (dimension === "width") ? "left" : "top";
    const width = this.getWidth();
    const height = this.getHeight();
    const top = this.props.top;
    const left = this.props.left;
    const size = this.getDimension(dimension) || 0;
    const children = [];
    let remainingSize = size;
    let totalFlexUnits = 0;

    React.Children.forEach(this.props.children,(child)=>{

      if (!child) { return; }

      const flex = getFlex(child);

      if (child.props.size) {
        remainingSize -= parseFloat(child.props.size);
      }
      else if (flex) {
        totalFlexUnits += parseFloat(flex);
      }
      else {
        const sze = child.key && (this.state.measured != null ? this.state.measured[child.key] : (this.state.lastMeasured[child.key] || 0));
        remainingSize -= sze;
      }
    });

    const flexUnitSize = remainingSize / totalFlexUnits;
    let pos = 0;

    React.Children.forEach(this.props.children,(child,index)=>{

      if (!child) { return; }

      const additionalProps = {};
      let sze;
      const flex = getFlex(child);


      additionalProps.key = child.key || (`_child${index}`);


      if (child.props.size) {
        sze = child.props.size;
      }
      else if (flex) {
        sze = parseFloat(flex) * flexUnitSize;
      }
      else if (child.key) {
        additionalProps["data-cm-layout-key"] = child.key;
        sze = this.state.measured[child.key] || 0;
      }

      let l;
      let t;
      let w;
      let h;

      if (dimension === "height") {
        if (child.props.size || flex) {
          h = sze;
        }
        t = pos;
      }
      else {
        if (child.props.size || flex) {
          w = sze;
        }
        l = pos;
      }
      pos += (parseFloat(sze) || 0);


      if (isString(child.type)) {

        var styl = {};

        if (dimension === "height") {
          styl.width = "100%";
        }
        else {
          styl.height = "100%";
        }

        l = l || 0;
        t = t || 0;
        styl.left = `${l}px`;
        styl.top = `${t}px`;
        styl.position = "absolute";


        if (isNumber(h)) {
          styl.height = `${h}px`;
        }

        if (isNumber(w)) {
          styl.width = `${w}px`;
        }

        styl = extend(styl,child.props.style);
        additionalProps.style = styl;
      }
      else {

        if (!isNaN(l)) { additionalProps.left = l; }
        if (!isNaN(t)) { additionalProps.top = t; }
        if (!isNaN(w)) { additionalProps.width = w; }
        if (!isNaN(h)) { additionalProps.height = h; }

      }

      const props = mergeProps(child.props,additionalProps);

      const newChild = React.cloneElement(child,props);

      children.push(newChild);

    });

    let style = {overflow: "hidden"};

    if (isNumber(left) || isNumber(top)) {
      style = {
        position: "absolute",
        left: "0px",
        top: "0px",
        height: "100%",
        width: "100%"
      };

      if (isNumber(left)) {
        style.left = `${left}px`;
      }

      if (isNumber(top)) {
        style.top = `${top}px`;
      }

      if (isNumber(height)) {
        style.height = `${height}px`;
      }
      else if (dimension === "height") {
        style.height = `${pos}px`;
      }

      if (isNumber(width)) {
        style.width = `${width}px`;
      }
      else if (dimension === "width") {
        style.width = `${pos}px`;
      }

    }

    if (this.props.style) {
      extend(style,this.props.style);
    }

    this.renderedChildren = children;

    let componentProps = mergeProps({className: this.props.className},this.props.componentProps,{style: style});

    if (isString(this.props.component)) {
      componentProps = pickHtmlProps(componentProps);
    }

    return (
      React.createElement(this.props.component,componentProps,children)
    );
  }

}

Layout.propTypes = {
  width: PropTypes.number,
  height: PropTypes.number,
  children: PropTypes.node,
  dimension: PropTypes.oneOf(["width","height"]),
  top: PropTypes.number,
  left: PropTypes.number,
  style: PropTypes.object,
  className: PropTypes.string,
  componentProps: PropTypes.object,
  component: PropTypes.component,
};

Layout.defaultProps = {
  component: Panel,
};



export function VBox(props) {
  const newProps = mergeProps({className: "vbox"},props);
  return <Layout dimension="height" {...newProps} />;
}

export function HBox(props) {
  const newProps = mergeProps({className: "hbox"},props);
  return <Layout dimension="width" {...newProps} />;
}

export function CBox(props) {

  const component = props.component || Panel;
  const innerComponent = props.innerComponent || "div";
  let innerProps = props.innerProps || {};

  const outerStyle = extend({
    height: props.height,
    width: props.width,
    top: props.top,
    left: props.left,
    display: "table",
    position: "absolute"
  },props.style);

  let outerProps = mergeProps({className: "cbox"},props,{style: outerStyle});

  const innerStyle = extend({
    display: "table-cell",
    textAlign: "center",
    verticalAlign: "middle"
  },innerProps.style);

  innerProps = mergeProps({className: "cbox-inner"},props.innerProps,{style: innerStyle});

  if (isString(innerComponent)) {
    innerProps = pickHtmlProps(innerProps);
  }

  const inner = React.createElement(innerComponent,innerProps,props.children);

  if (isString(component)) {
    outerProps = pickHtmlProps(outerProps);
  }

  return React.createElement(component, outerProps, inner);
}

CBox.propTypes = {
  component: PropTypes.component,
  innerComponent: PropTypes.component,
  innerProps: PropTypes.object,
  height: PropTypes.number,
  width: PropTypes.number,
  top: PropTypes.number,
  left: PropTypes.number,
  style: PropTypes.object,
  children: PropTypes.node,
};
