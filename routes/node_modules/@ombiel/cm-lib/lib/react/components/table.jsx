import "./base.aekcss";
import "./table.aekcss";

import {isString,includes,isObject,isArray,map,isNumber,values,mapValues,keys,extend} from "lodash";

import React from "react";
import PropTypes from "prop-types";
import pickHtmlProps from "../utils/pick-html-props";
import mergeProps from "../utils/merge-props";
import {Segment} from "./segment";

export function TableCell(props) {

  const style = {};

  const {align} = props;

  if (isString(align)) {
    align.split(" ").forEach((a)=>{
      if (includes(["left","center","right"],a)) {
        style.textAlign = a;
      }
      else if (includes(["top","middle","bottom"],a)) {
        style.verticalAlign = a;
      }
    });
  }

  let newProps = mergeProps({
    classSet: {
      collapsing: props.collapsing,
      positive: props.positive,
      negative: props.negative,
      error: props.error,
      warning: props.warning,
      active: props.active,
      disabled: props.disabled
    },
    style
  },props);

  const component = props.component || "td";
  let {children} = props;

  if (!children) { children = props.text; }

  if (isString(component)) {
    newProps = pickHtmlProps(newProps,{exclude: ["data"]});
  }

  return React.createElement(component,newProps,children);
}

TableCell.propTypes = {
  align: PropTypes.string,
  collapsing: PropTypes.bool,
  positive: PropTypes.bool,
  negative: PropTypes.bool,
  error: PropTypes.bool,
  warning: PropTypes.bool,
  active: PropTypes.bool,
  disabled: PropTypes.bool,
  component: PropTypes.any,
  children: PropTypes.any,
  text: PropTypes.string,
};

export function TableLabelCell(props) {
  const newProps = mergeProps({collapsing: true},props,{component: "th"});
  return <TableCell {...newProps} />;
}

export function TableHeaderCell(props) {
  const newProps = mergeProps(props,{component: "th"});
  return <TableCell {...newProps} />;
}

export function TableRow(props) {
  let {children} = props;
  if (!children) {
    const data = props.data || [];
    const {cellProps} = props;
    children = data.map((item,i)=>{
      const itemProps = mergeProps({key: `cell${i}`},cellProps);

      if (React.isValidElement(item)) {
        return item;
      }
      else if (isObject(item)) {
        return React.createElement(TableCell,mergeProps(itemProps,item));
      }
      return <TableCell {...itemProps}>{item}</TableCell>;
    });
  }

  const newProps = pickHtmlProps(props,{exclude: ["data"]});

  return <tr {...newProps}>{children}</tr>;
}

TableRow.propTypes = {
  children: PropTypes.any,
  data: PropTypes.oneOfType([PropTypes.object,PropTypes.array]),
  cellProps: PropTypes.object,
};


export function TableBody(props) {
  let {children} = props;
  if (!children) {
    let data = props.data || [];
    const {cellProps,labelCellProps,rowProps} = props;
    if (!isArray(data)) {
      const {columns} = props;

      data = values(mapValues(data,(item,key)=>{
        let rowData;
        if (columns) {
          rowData = columns.map(k=>item[k]);
        }
        else if (isArray(item)) {
          rowData = item;
        }
        else {
          rowData = [item];
        }

        return [<TableLabelCell {...mergeProps({key: "label",text: key,data: rowData},labelCellProps)} />].concat(rowData);
      }));
    }
    children = data.map((item,i)=>{
      if (React.isValidElement(item)) { return item; }
      const itemProps = mergeProps({key: `row${i}`,data: item,cellProps},rowProps);
      return <TableRow {...itemProps} />;
    });
  }

  const newProps = pickHtmlProps(props,{exclude: ["data"]});

  return <tbody {...newProps}>{children}</tbody>;
}

TableBody.propTypes = {
  children: PropTypes.any,
  data: PropTypes.oneOfType([PropTypes.object,PropTypes.array]),
  cellProps: PropTypes.object,
  labelCellProps: PropTypes.object,
  rowProps: PropTypes.object,
  columns: PropTypes.array,
};


export function TableHeader(props) {
  let {children} = props;
  if (!children) {
    var data = props.data || [];
    let {cellProps,rowProps} = props;
    cellProps = mergeProps({component: TableHeaderCell},cellProps);
    rowProps = mergeProps({data,cellProps},rowProps);
    children = <TableRow {...rowProps} />;
  }

  const newProps = pickHtmlProps(props,{exclude: ["data"]});

  return <thead {...newProps}>{children}</thead>;
}

TableHeader.propTypes = {
  children: PropTypes.any,
  data: PropTypes.oneOfType([PropTypes.object,PropTypes.array]),
  cellProps: PropTypes.object,
  rowProps: PropTypes.object,
};


export function Table(props) {

  let newProps = mergeProps({
    className: `ui ${props.theme || ""} table`,
    classSet: {
      unstackable: !props.stackable,
      padded: props.padded,
      "very compact": props.compact,
      small: props.small,
      large: props.large,
      celled: props.celled,
      basic: props.basic,
      inverted: props.inverted,
      flush: props.flush
    }
  },props);

  let {children} = props;

  if (!children) {
    children = [];
    let {headerCells,columns,headerProps,bodyProps} = props;
    const {data,cellProps,rowProps,labelCellProps} = props;

    columns = columns && columns.map((col)=>{
      if (isString(col) || isNumber(col)) {
        return {[col]: col};
      }
      return col;
    });

    if (!headerCells && columns) {
      headerCells = columns.map((col)=>{
        return values(col)[0];
      });
    }
    if (headerCells) {
      headerProps = mergeProps({cellProps,rowProps,data: headerCells,key: "header"},headerProps);
      children.push(<TableHeader {...headerProps} />);
    }
    bodyProps = mergeProps({
      cellProps,
      rowProps,
      labelCellProps,
      data: data,
      columns: columns && columns.map((col)=>keys(col)[0]).slice(1),
      key: "body"
    },bodyProps);
    children.push(<TableBody {...bodyProps} />);
  }

  newProps = pickHtmlProps(newProps,{exclude: ["data"]});

  return <table {...newProps}>{children}</table>;

}

Table.propTypes = {
  theme: PropTypes.string,
  stackable: PropTypes.bool,
  padded: PropTypes.bool,
  compact: PropTypes.bool,
  small: PropTypes.bool,
  large: PropTypes.bool,
  celled: PropTypes.bool,
  basic: PropTypes.bool,
  inverted: PropTypes.bool,
  flush: PropTypes.bool,
  children: PropTypes.any,
  headerCells: PropTypes.array,
  columns: PropTypes.array,
  headerProps: PropTypes.object,
  bodyProps: PropTypes.object,
  data: PropTypes.oneOfType([PropTypes.object,PropTypes.array]),
  cellProps: PropTypes.object,
  rowProps: PropTypes.object,
  labelCellProps: PropTypes.object,
};

export function TableSegment(props) {

  const newProps = mergeProps({
    className: "table-segment",
    style: {
      width: "100%",
      padding: 0,
      overflow: "auto"
    }
  },props);

  return <Segment {...newProps} />;
}


extend(Table,{
  Table,
  TableSegment,
  TableCell,
  TableRow,
  TableBody,
  TableHeaderCell,
  TableHeader,
  TableLabelCell,
  Cell: TableCell,
  Row: TableRow,
  HeaderCell: TableHeaderCell,
  LabelCell: TableLabelCell
});
