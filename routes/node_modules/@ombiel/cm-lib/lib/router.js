/* eslint-disable no-bitwise,no-plusplus */

import pathtoRegexp from "path-to-regexp";
import {extend,without,forEach} from "lodash";

import {parseQueryString,param} from "./utils";

/**
   * Initialize `Route` with the given HTTP `path`,
   * and an array of `callbacks` and `options`.
   *
   * Options:
   *
   *   - `sensitive`    enable case-sensitive routes
   *   - `strict`       enable strict matching for trailing slashes
   *
   * @param {String} path
   * @param {Object} options.
   * @api private
   */

export function Route(path, options) {
  options = options || {};
  this.path = path;
  this.method = 'GET';
  this.regexp = pathtoRegexp(this.path,
    this.keys = [],
    options.sensitive,
    options.strict);
}


/**
 * Return route middleware with
 * the given callback `fn()`.
 *
 * @param {Function} fn
 * @return {Function}
 * @api public
 */

Route.prototype.middleware = function(fn) {
  var self = this;
  return function(ctx, next) {
    if (self.match(ctx.path, ctx.params)) { return fn(ctx, next); }
    next();
    return null;
  };
};

/**
 * Check if this route matches `path`, if so
 * populate `params`.
 *
 * @param {String} path
 * @param {Array} params
 * @return {Boolean}
 * @api private
 */

Route.prototype.match = function(path, params) {
  const keys = this.keys;
  const qsIndex = path.indexOf('?');
  const pathname = ~qsIndex
    ? path.slice(0, qsIndex)
    : path;
  const m = this.regexp.exec(decodeURIComponent(pathname));

  if (!m) { return false; }

  for (var i = 1, len = m.length; i < len; ++i) {
    var key = keys[i - 1];

    var val = (typeof m[i] === 'string')
      ? decodeURIComponent(m[i])
      : m[i];

    if (key) {
      params[key.name] = undefined !== params[key.name]
        ? params[key.name]
        : val;
    }
    else {
      params.push(val);
    }
  }

  return true;
};




function Context(path) {

  var i = path.indexOf('?');

  this.canonicalPath = path;
  this.path = path;//.replace(base, '') || '/';

  this.title = document.title;
  // this.state = state || {};
  // this.state.path = path;
  this.querystring = ~i
    ? path.slice(i + 1)
    : '';
  this.pathname = ~i
    ? path.slice(0, i)
    : path;
  this.params = [];

  this.query = parseQueryString(this.querystring);

  // fragment
  this.hash = '';
  if (!~this.path.indexOf('#')) { return; }
  var parts = this.path.split('#');
  this.path = parts[0];
  this.hash = parts[1] || '';
  this.querystring = this.querystring.split('#')[0];
}


Context.prototype.modifyQuery = function(newParams,replace) {
  var params = extend({},this.query,newParams);
  var queryString = param(params);
  if (queryString) { queryString = `?${queryString}`; }
  this.router[replace === ("back" && "backTo") || (replace && "replace") || "goto"](this.pathname + queryString);
};

// /**
//  * Push state.
//  *
//  * @api private
//  */

// Context.prototype.pushState = function(){
//   history.pushState(this.state
//     , this.title
//     , hashbang && this.path !== '/'
//       ? '#!' + this.path
//       : this.canonicalPath);
// };

/**
 * Save the context state.
 *
 * @api public
 */

// Context.prototype.save = function(){
//   history.replaceState(this.state
//     , this.title
//     , hashbang && this.path !== '/'
//       ? '#!' + this.path
//       : this.canonicalPath);
// };






export class Router {
  constructor(opts = {}) {
    this.opts = opts;
    this.history = [window.location.hash.substr(1) || "/"];
    this.historyState = {};
    this.currentHistoryIndex = 0;

    this.onClick = this.onClick.bind(this);

    if (opts.useHash) {
      this.useHash = true;
      this.onHashChange = this.onHashChange.bind(this);
    }

    if (this.useHash) {
      if (window.history.state && window.history.state.history) {
        this.history = window.history.state.history;
        if (window.history.state.historyState != null) {
          this.historyState = window.history.state.historyState;
        }
        if (window.history.state.currentHistoryIndex != null) {
          this.currentHistoryIndex = window.history.state.currentHistoryIndex;
        }
      }
      else {
        this.resetState();
      }
    }
    else if (!opts.noPolyfill) {
      /*
        polyfill to use link elements in iOS
        Currently iOS native app intercepts hash changes and launches a new webview to load them into
        */

      document.addEventListener("click",this.onClick,false);
    }

    this.callbacks = [];

  }

  onClick(e) {

    var target = e.target;
    var a;
    while (!a && target) {
      if (target.tagName && target.tagName.toLowerCase() === "a") {
        a = target;
      }
      target = target.parentElement;
    }
    if (a) {
      var href = a.getAttribute("href");
      if (href.indexOf("#/") === 0) {
        this.goto(href);
        e.preventDefault();
      }
    }
  }

  addRoute(path,cb) {
    var route = new Route(path);
    const callback = route.middleware(cb);
    this.callbacks.push(callback);
    return callback;
  }

  removeRoute(cb) {
    this.callbacks = without(this.callbacks,cb);
  }

  start(opts = {}) {

    if (this._started) {
      return;
    }
    this._started = true;

    extend(this.opts,opts);
    if (this._running) { return; }
    this._running = true;

    var startPath = window.location.hash.substr(1);
    if (this.useHash) {
      window.addEventListener('hashchange', this.onHashChange, false);
    }

    if (!startPath) {
      startPath = "/";
    }

    var router = this;
    window.goBack = function() {
      return router.goBack();
    };

    this.show(startPath);

  }

  getHistoryState(index) {
    return this.historyState[index] || {};
  }

  setHistoryState(index,state) {
    this.historyState[index] = state;
  }

  updateHistoryState(index,state) {
    this.setHistoryState(index,extend({},this.getHistoryState(index),state));
  }

  show(path,direction = "forward") {
    path = this.cleanPath(path);
    const ctx = new Context(path);
    this.currentCtx = ctx;
    this.currentContext = ctx;
    Router.currentContext = ctx;
    ctx.router = this;
    ctx.transitionDirection = direction;
    ctx.historyIndex = this.currentHistoryIndex;
    ctx.getHistoryState = this.getHistoryState.bind(this,this.currentHistoryIndex);
    ctx.setHistoryState = this.setHistoryState.bind(this,this.currentHistoryIndex);
    ctx.updateHistoryState = this.updateHistoryState.bind(this,this.currentHistoryIndex);
    this.dispatch(ctx);

    // var currentHistoryIndex = this.currentHistoryIndex;
    // this.history.forEach(function(path,i) {
    //   // console.log(i,path,(i==currentHistoryIndex && "CURRENT" || ""))
    // });

    return ctx;
  }

  dispatch(ctx) {
    var i = 0;
    var router = this;
    function next() {
      var fn = router.callbacks[i++];
      if (!fn) {
        return router.unhandled(ctx);
      }
      fn(ctx, next);
      return null;
    }

    next();
  }

  cleanPath(path) {
    if (path === "*") {
      return "*";
    }
    path = path.replace("#","");
    if (path.indexOf("/") !== 0) {
      path = `/${path}`;
    }
    return path;
  }

  getCurrentPath() {
    return this.history[this.currentHistoryIndex];
  }

  replace(path) {
    path = this.cleanPath(path);
    if (path === this.getCurrentPath()) {
      return;
    }
    this.history = this.history
    .slice(0,this.currentHistoryIndex)
    .concat([path])
    .concat(this.history.slice(this.currentHistoryIndex + 1));

    // remove historyState
    this.setHistoryState(this.currentHistoryIndex,{});

    if (this.useHash) {
      this._silentHashChange = true;
      window.location.replace(`#${path}`);
    }
    this.show(path);
  }

  goto(path) {
    path = this.cleanPath(path);
    if (path === this.getCurrentPath()) {
      return;
    }
    // console.log("GOTO",path)

    // clear historyState in front
    forEach(this.historyState,function(state,index) {
      if (index > this.currentHistoryIndex) {
        this.setHistoryState(index,{});
      }
    }.bind(this));

    this.currentHistoryIndex++;
    this.history = this.history.slice(0,this.currentHistoryIndex).concat([path]);
    this.show(path);
    this.updateHash(path);
  }

  backTo(path,useHash = true) {
    path = this.cleanPath(path);
    if (path === this.getCurrentPath()) {
      return;
    }
    var historyIndex = this.history.indexOf(path);
    if (historyIndex > -1) {
      this.goBack(this.currentHistoryIndex - historyIndex,useHash);
    }
    else {
      this.goto(path);
    }
  }

  goBack(steps = 1,useHash = true) {
    if (this.useHash && useHash) {
      window.history.go(-steps);
      return null;
    }

    this.currentHistoryIndex -= steps;
    var returnVal = true;
    if (this.currentHistoryIndex < 0) {
      this.currentHistoryIndex = 0;
      returnVal = false;
    }
    var path = this.history[this.currentHistoryIndex];
    this.updateHash(path);
    this.show(path,"back");

    return returnVal;
  }

  unhandled() { // has ctx argument

  }

  updateHash(path) {
    path = this.cleanPath(path);
    if (this.useHash && path !== window.location.hash.substr(1)) {
      this._silentHashChange = true;
      if (path === "/") {
        if (window.location.hash) {
          window.location.hash = "";
        }
      }
      else {
        window.location.hash = path;
      }
    }
  }

  onHashChange() {
    if (!this._silentHashChange) {

      var path = window.location.hash.substr(1);
      path = this.cleanPath(path);
      var historyIndex = this.history.indexOf(path);
      var historyState = this.useHash && window.history.state;

      if (historyState) {
        if (window.history.state.currentHistoryIndex != null) {
          historyIndex = window.history.state.currentHistoryIndex;
        }
      }

      if (historyIndex > -1 && historyIndex < this.currentHistoryIndex && historyState) {
        this.goBack(this.currentHistoryIndex - historyIndex,false);
      }
      else {
        this.goto(path);
      }
    }
    this._silentHashChange = false;

    this.resetState();
  }

  resetState() {
    if (window.history.replaceState) {
      window.history.replaceState({currentHistoryIndex: this.currentHistoryIndex,history: this.history,historyState: this.historyState},"");
    }
  }

  stop() {
    document.removeEventListener('click',this.onClick,false);
    if (!this._running) { return; }
    this._running = false;
    window.removeEventListener('hashchange', this.onHashChange, false);
  }
}
