import {isArray,isEqual,isString,has,isFunction,get,includes,forEach,keys,extend as _extend} from "lodash";

import EventEmitter from "../event-emitter";

import Immutable from "seamless-immutable";

var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\n\\]|\\.)*?)\2)\]/g;

/**
 * Converts `value` to property path array if it's not one.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {Array} Returns the property path array.
 */
function toPath(value) {
  if (isArray(value)) {
    return value;
  }
  var result = [];
  value.replace(rePropName, function(match, number, quote, string) {
    result.push(quote ? string.replace(/\\(\\)?/g, '$1') : (number || match));
  });
  return result;
}

// remove circular refs and functions
function clean(obj,refs = []) {
  if (!obj) { return obj; }
  if (Immutable.isImmutable(obj)) { return obj; }
  if (typeof obj === "function") {
    return "[Function]";
  }
  if (typeof obj === "object") {
    if (includes(refs,obj)) {
      return "[Circular]";
    }
    refs = refs.concat([obj]);

    if (isArray(obj)) {
      return obj.map((item)=>{
        return clean(item,refs);
      });
    }

    var cleaned = {};
    forEach(keys(obj),(key)=>{
      cleaned[key] = clean(obj[key],refs);
    });
    return cleaned;
  }

  return obj;
}

class StoreContext {

  constructor(store,base) {
    this.store = store;
    this.base = base;
    this.promise = Promise.resolve();
  }

  dispatch(desc) {
    if (desc.error) { desc = _extend({name: "error"},desc); }
    return this.store.dispatch(_extend({},this.base,desc));
  }

  get(path,defaultValue) {
    const basePath = get(this,"base.path");
    const object = basePath ? this.store.get(basePath) : this.store.state;
    if (!path) {
      return object == null ? defaultValue : object;
    }
    return get(object,path,defaultValue);

  }

  addChangeListener(cb) {
    return this.store.addChangeListener(get(this,"base.path"),cb);
  }

}

export default class SimpleStore extends EventEmitter {

  constructor(opts) {

    opts = _extend({plugins: [],initialState: {}},opts);

    super();

    this.state = Immutable.from(opts.initialState);

    this.constructor.plugins.forEach((plugin)=>{
      this.plugin(plugin);
    });

    opts.plugins.forEach((plugin)=>{
      this.plugin(plugin);
    });

    this.prevState = this.state;

    this.emit("init",this.state);

  }

  asMutable(obj) {
    if (obj && obj.asMutable) {
      return Immutable.asMutable(obj,{deep: true});
    }
    return obj;
  }

  checkChange() {
    if (isEqual(this.prevState,this.state)) {
      this.emit("nochange",this.state);
    }
    else {
      this.emit("change",this.state,this.prevState);
    }
    this.prevState = this.state;
  }

  dispatch(desc) {
    this.emit("dispatch",desc);

    var {group,name,path,payload,replace,extend} = desc;

    if (!(group || name)) { throw Error("Dispatch must include a group or name"); }
    if (!(isString(path) || isArray(path))) { throw Error("Dispatch must include a valid path"); }
    if (!has(desc,"replace") && !has(desc,"extend")) { throw Error("Dispatch must include a modifier (extend or replace)"); }

    if (extend && (replace == null)) {
      if (isFunction(extend)) {
        replace = (state,pload)=>_extend(state,extend(state,pload));
      }
      else {
        replace = ()=>_extend({},this.get(path),extend);
      }
    }

    if (!isFunction(replace)) {
      const v = replace;
      replace = ()=>v;
    }

    var newState;
    var val;

    if (replace.length) {
      val = replace(this.asMutable(this.get(path)),payload);
    }

    else {
      val = replace();
    }

    // clean payload
    var cleaned = clean(val);

    if (!path) {
      newState = Immutable.replace(this.state,cleaned,{deep: true});
    }
    else {
      newState = Immutable.setIn(this.state,toPath(path),cleaned,{deep: true});
    }

    this.state = newState;
    this.checkChange();

  }

  context(base) {
    return new StoreContext(this,base);
  }

  get(path,defaultValue) {
    if (!path) {
      return this.state || Immutable.from(defaultValue);
    }
    return get(this.state,path,Immutable.from(defaultValue));
  }

  set(path,val) {
    val = clean(val);
    this.emit("set",path,val);
    if (!path) {
      this.state = Immutable.replace(this.state,val,{deep: true});
    }
    else {
      this.state = Immutable.setIn(this.state,toPath(path),val,{deep: true});
    }
    this.checkChange();
  }

  plugin(plugin) {
    plugin(this);
  }

  addChangeListener(path,cb) {
    let prevValue = this.get(path);

    const onChange = ()=>{
      const newValue = this.get(path);
      if (!isEqual(prevValue,newValue)) {
        prevValue = newValue;
        cb(newValue);
      }
    };

    this.on("change",onChange);

    return {
      stop: ()=>{
        this.off("change",onChange);
      }
    };

  }

}

SimpleStore.plugins = [];
